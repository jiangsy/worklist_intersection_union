metavar var, x, y, z ::= {{ repr-locally-nameless }}


grammar

ld_type, t, A, B :: 'ld_t_' ::= 
  | int           ::   :: int
  | forall x . t  ::   :: forall (+ bind x in t +)
  | t1 -> t2      ::   :: arrow
  | x             ::   :: var
  | ( t )         :: S :: paren {{ coq [[t]] }} 
  | [ t / x ] A   :: M :: susbt {{ coq (open_ld_type_wrt_ld_type [[x A]] [[t]]) }}

ld_work, w :: 'ld_w_' ::= 
  | t1 <: t2       :: :: sub

ld_worklist, wl :: 'ld_wl_' ::= 
  | nil            :: :: nil 
  | wl , x         :: :: cons_tv
  | wl |- w        :: :: cons_w

ld_context, G :: 'ld_ctx_' ::=
  | nil            ::   :: nil
  | G , x          ::   :: cons
  | [| wl |]       :: M :: wl {{ coq (ld_wl_to_ctx [[wl]]) }}

formula :: formula_ ::=
  | judgement     ::   :: judgement
  | x ∉ G         :: M :: ctx_fresh {{ coq ([[x]] `notin` ld_ctx_dom [[G]]) }}

substitutions
  single ld_type x :: subst


freevars
  ld_type    x  :: fv

embed {{ coq

Fixpoint ld_wl_app (wl1 wl2 : ld_worklist) : ld_worklist :=
  match wl2 with
  | ld_wl_nil => wl1 
  | ld_wl_cons_w wl2' w2 => ld_wl_cons_w (ld_wl_app wl1 wl2') w2
  | ld_wl_cons_tv wl2' x => ld_wl_cons_tv (ld_wl_app wl1 wl2') x
  end
.

Fixpoint ld_ctx_dom (G : ld_context) : atoms :=
  match G with
  | ld_ctx_nil => {}
  | ld_ctx_cons G' x => add x (ld_ctx_dom G')
  end
.

Fixpoint ld_wl_to_ctx (wl : ld_worklist) : ld_context := 
  match wl with 
  | ld_wl_nil                     => ld_ctx_nil
  | ld_wl_cons_tv wl' x              => ld_ctx_cons (ld_wl_to_ctx wl') x 
  | ld_wl_cons_w wl' _              => ld_wl_to_ctx wl'
  end
.

}}


defns
Monotype :: '' ::=

defn
mono A :: :: ld_mono_type :: 'ld_mono_'
by

--------------- :: int
mono int

--------------- :: var
mono x

mono t1
mono t2
--------------- :: arrow
mono t1 -> t2


defns
NotForallType :: '' ::=

defn
~∀ A :: :: ld_notforall_type :: 'ld_nf_'
by

--------------- :: int
~∀ int

--------------- :: var
~∀ x

--------------- :: arrow
~∀ t1 -> t2


defns
InContext :: '' ::=

defn
x in G :: :: ld_in_context :: 'ld_inc_'
by

------------------ :: here
x in G, x 

x in G
------------------ :: there
x in G, y 



defns
WellFormedContext :: '' ::=

defn
|=> G :: :: ld_wf_context :: 'ld_wfc_'
by

------------ :: nil
|=> nil

|=> G
x ∉ G
------------ :: cons
|=> G , x


defns
WellFormedType :: '' ::=

defn
G |=> t  :: :: ld_wf_type :: 'ld_wft_'
by

|=> G
---------------- :: int
G |=>  int

|=> G
x in G 
---------------- :: var
G |=> x

G |=>  t1 
G |=>  t2 
---------------- :: arrow
G |=>  t1 -> t2

G , x |=> t 
----------------- :: forall 
G |=> forall x. t


defns
WellFormedMonoType :: '' ::=

defn
G |==> t  :: :: ld_wf_mtype :: 'ld_wfmt_'
by

|=> G
---------------- :: int
G |==> int

|=> G
x in G 
---------------- :: var
G |==> x

G |==> t1
G |==> t2 
---------------- :: arrow
G |==> t1 -> t2


defns
DeclarativeSubtyping :: '' ::=

defn
G |- t1 <: t2 :: :: ld_sub :: 'ld_sub_'
by

|=> G
x in G
------------------- :: var
G |- x <: x

|=> G
------------------- :: int
G |- int <: int

G |- B1 <: A1
G |- A2 <: B2
------------------- :: arrow
G |- A1 -> A2 <: B1 -> B2

~∀ B
G |==> t
G |- [ t / x ] A <: B
------------------- :: foralll
G |- forall x. A <: B

G , x |- A <: B
-------------------------- :: forallr
G |- A <: forall x. B


defns
DeclarativeWorklistSubtyping :: '' ::=

defn
|- wl :: :: ld_worklist_reducible :: 'ld_wlred_'
by

-------------------- :: nil
|- nil

|=> [| wl , x|]
|- wl
------------------- :: cons_tvar
|- wl , x


[| wl |] |- t1 <: t2
|- wl
--------------------------- :: sub
|- wl |- t1 <: t2 


