metavar var, x, y, z ::= {{ repr-locally-nameless }}


grammar

ld_type, t, A, B :: 'ld_t_' ::= 
  | int           ::   :: int
  | forall x . t  ::   :: forall (+ bind x in t +)
  | t1 -> t2      ::   :: arrow
  | x             ::   :: var
  | ( t )         :: S :: paren {{ coq [[t]] }} 
  | [ t / x ] A   :: M :: susbt {{ coq (open_ld_type_wrt_ld_type [[x A]] [[t]]) }}


ld_worklist, wl :: 'ld_wl_' ::= 
  | nil            :: :: nil 
  | wl , x         :: :: cons_tvar
  | wl , t1 <: t2  :: :: cons_sub

ld_context, G :: 'ld_ctx_' ::=
  | nil            ::   :: nil
  | G , x          ::   :: cons
  | [| wl |]       :: M :: wl {{ coq (wl_to_ctx [[wl]]) }}

formula :: formula_ ::=
  | judgement     ::   :: judgement
  | x notin G     :: M :: ctx_fresh {{ coq ([[x]] `notin` ctx_dom [[G]]) }}

substitutions
  single ld_type x :: subst


freevars
  ld_type    x :: fv


embed {{ coq

Fixpoint ctx_dom (G : ld_context) : atoms :=
  match G with
  | ld_ctx_nil => {}
  | ld_ctx_cons G' x => add x (ctx_dom G')
  end
.

Fixpoint wl_to_ctx (wl : ld_worklist) : ld_context := 
  match wl with
  | ld_wl_nil               => ld_ctx_nil
  | ld_wl_cons_tvar wl' x   => ld_ctx_cons (wl_to_ctx wl') x 
  | ld_wl_cons_sub wl' t1 t2 => wl_to_ctx wl'
  end
.

}}


defns
Monotype :: '' ::=

defn
mono A :: :: ld_mono_type :: 'ld_mono_'
by

--------------- :: int
mono int

--------------- :: var
mono x

mono t1
mono t2
--------------- :: arrow
mono t1 -> t2

defns
NotForallType :: '' ::=

defn
!forall A :: :: ld_notforall_type :: 'ld_nf_'
by

--------------- :: int
!forall int

--------------- :: var
!forall x

--------------- :: arrow
!forall t1 -> t2


defns
InContext :: '' ::=

defn
x in G :: :: ld_in_context :: 'ld_inc_'
by

------------------ :: here
x in G, x 

x in G
------------------ :: there
x in G, y 



defns
WellFormedContext :: '' ::=

defn
|=> G :: :: ld_wf_context :: 'ld_wfc_'
by

---------- :: nil
|=> nil

|=> G
x notin G
---------- :: cons
|=> G , x


defns
WellFormedType :: '' ::=

defn
G |=> t  :: :: ld_wf_type :: 'ld_wft_'
by

|=> G
---------------- :: int
G |=>  int

|=> G
x in G 
---------------- :: var
G |=>  x

G |=>  t1 
G |=>  t2 
---------------- :: arrow
G |=>  t1 -> t2

G , x |=> t 
----------------- :: forall 
G |=> forall x. t


defns
WellFormedMonoType :: '' ::=

defn
G |==> t  :: :: ld_wf_mtype :: 'ld_wfmt_'
by

|=> G
---------------- :: int
G |==> int

|=> G
x in G 
---------------- :: var
G |==>  x

G |==> t1
G |==> t2 
---------------- :: arrow
G |==> t1 -> t2


defns
DeclarativeSubtyping :: '' ::=

defn
G |- t1 <: t2 :: :: ld_sub :: 'ld_sub_'
by

|=> G
x in G
------------------- :: var
G |- x <: x

|=> G
------------------- :: int
G |- int <: int

G |- B1 <: A1
G |- A2 <: B2
------------------- :: arrow
G |- A1 -> A2 <: B1 -> B2

!forall B
G |==> t
G |- [ t / x ] A <: B
------------------- :: foralll
G |- forall x. A <: B

G , x |- A <: B
------------------- :: forallr
G |- A <: forall x. B


defns
DeclarativeWorklistSubtyping :: '' ::=

defn
|- wl :: :: ld_worklist_reducible :: 'ld_wlred_'
by

---------- :: nil
|- nil

|=> [| wl , x|]
|- wl
------------ :: cons_tvar
|- wl , x


[| wl |] |- t1 <: t2
|- wl
--------------------------- :: sub
|- wl , t1 <: t2 


