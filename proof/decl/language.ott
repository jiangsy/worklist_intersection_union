
metavar var, x, y, z ::= {{ repr-locally-nameless }}


grammar

type, t, A, B :: 'ld_t_' ::= 
  | int           :: :: int
  | forall x . t  :: :: forall (+ bind x in t +)
  | t1 -> t2      :: :: arrow
  | x             :: :: var
  | ( t )         :: S :: paren {{ coq [[t]] }} 
  | [ t / x ] A   :: M :: susbt {{ coq (open_type_wrt_type [[x A]] [[t]]) }}

context, G :: 'ld_ctx_' ::=
  | nil     :: :: nil
  | G , x  :: :: cons

formula :: formula_ ::=
  | judgement  ::   :: judgement
  | x # G      :: M :: ctx_fresh {{ coq ([[x]] `notin` ctx_dom [[G]]) }}
  | x $ G      :: M :: ctx_in {{ coq ([[x]] `in` ctx_dom [[G]]) }}

substitutions
  single type x :: subst

freevars
  type    x :: fv

embed {{ coq

Fixpoint ctx_dom (G : context) : atoms :=
  match G with
  | ld_ctx_nil => {}
  | ld_ctx_cons G' x => add x (ctx_dom G')
  end
.

}}

defns
Monotype :: '' ::=

defn
mono A :: :: mono_type :: 'ld_mono_'
by

--------------- :: int
mono int

--------------- :: var
mono x

mono t1
mono t2
--------------- :: arrow
mono t1 -> t2


defns
DeclarativeSubtyping :: '' ::=

defn
|- G :: :: wf_context :: 'ld_wf_ctx_'
by

---------- :: nil
|- nil

|- G
x # G
---------- :: cons
|- G , x

defn
G |- t  :: :: wf_type :: 'ld_wf_typ_'
by

|- G
---------------- :: int
G |- int

|- G
x $ G 
---------------- :: var
G |- x

|- G
G |- t1 
G |- t2 
---------------- :: arrow
G |- t1 -> t2


defn
G |- t1 <: t2 :: :: sub :: 'ld_sub_'
by

x $ G
|- G
------------------- :: var
G |- x <: x

|- G
------------------- :: int
G |- int <: int


G |- B1 <: A1
G |- A2 <: B2
------------------- :: arrow
G |- A1 -> A2 <: B1 -> B2

G |- t
G |- [ t / x ] A <: B
------------------- :: forallL
G |- forall x. A <: B

G , x |- A <: B
------------------- :: forallR
G |- A <: forall x. B