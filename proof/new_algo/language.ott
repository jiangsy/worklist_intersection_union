
metavar x, y, z ::= {{ repr-locally-nameless }}
metavar ex, ey, ez ::= {{ coq var }}
metavar tx, ty, tz ::= {{ coq var }}


grammar

la_type, t, A, B :: 'la_t_' ::= 
  | int           ::   :: int
  | forall x . t  ::   :: forall (+ bind x in t +) 
  | t1 -> t2      ::   :: arrow 
  | x             ::   :: var
  | tx            ::   :: tvar
  | ex            ::   :: evar
  | ( t )         :: S :: paren {{ coq ([[t]]) }}
  | [ t / x ] A   :: M :: susbt {{ coq (open_la_type_wrt_la_type [[x A]] [[t]]) }}

la_typelist, tl :: 'la_tl_' ::= 
  | tnil    :: :: nil  
  | tl , t  :: :: cons 

la_work, w :: 'la_w_' ::=
  | tx               :: :: tvar 
  | tl ≤ ex ≤ tl'  :: :: evar
  | t1 <: t2         :: :: sub

la_mode, m :: 'la_m_' ::=
  | +                :: :: u
  | -                :: :: l


la_worklist, wl :: 'la_wl_' ::= 
  | wnil            ::   :: nil 
  | wl , w          ::   :: cons
  | wl1 ++ wl2      :: M :: app {{ coq (wl_app [[wl1]] [[wl2]]) }}
  | < tl >          :: M :: single_constraint {{ coq (single_side_constraints [[tl]]) }}
  | < tl1 * tl2 >   :: M :: double_constraint {{ coq (double_side_constraints [[tl1]] [[tl2]])}}
  | wl @ ex +> t    :: M :: update_lb {{ coq (update_lowerbound_in_wl [[t]] [[wl]] [[ex]]) }}
  | wl @ ex <+ t    :: M :: update_ub {{ coq (update_upperbound_in_wl [[t]] [[wl]] [[ex]]) }}
  | wl @ ex << ex1  :: M :: add_before {{ coq (add_evar_before [[ex1]] [[wl]] [[ex]])}}


formula :: formula_ ::=
  | judgement               ::   :: judgement
  | ex notin wl             :: M :: evar_fresh {{ coq ([[ex]] `notin` (evar_dom [[wl]])) }}
  | tx notin wl             :: M :: tvar_fresh {{ coq ([[tx]] `notin` (tvar_dom [[wl]])) }}
  | m { ex ∪ t } wl -> wl'  :: M :: reorder {{ coq (reorder [[wl]] [[ex]] [[t]] la_wl_nil [[wl']]) }}


substitutions
  single la_type x :: subst


freevars
  la_type  x   :: fv
  la_type  tx  :: ftx
  la_type  ex  :: fex


embed {{ coq

Fixpoint wl_app (wl1 wl2 : la_worklist) : la_worklist :=
  match wl2 with
  | la_wl_nil => wl1 
  | la_wl_cons wl2' w2 => la_wl_cons (wl_app wl1 wl2') w2
  end
.

Fixpoint tvar_dom (wl : la_worklist) : atoms :=
  match wl with
  | la_wl_nil => {}
  | la_wl_cons wl' (la_w_tvar tvar) => add tvar (tvar_dom wl')
  | la_wl_cons wl' _ => tvar_dom wl'
  end
.

Fixpoint evar_dom (wl : la_worklist) : atoms :=
  match wl with
  | la_wl_nil => {}
  | la_wl_cons wl' (la_w_evar _ evar _) => add evar (evar_dom wl')
  | la_wl_cons wl' _ => evar_dom wl'
  end
.

Fixpoint update_lowerbound_in_wl (t: la_type) (wl : la_worklist) (target : var) : la_worklist :=
  match wl with 
  | la_wl_nil => la_wl_nil
  | la_wl_cons wl' (la_w_evar tl evar tl') => 
    if (eq_dec target evar) 
      then la_wl_cons wl' (la_w_evar (la_tl_cons tl t) evar tl') 
      else la_wl_cons (update_lowerbound_in_wl t wl' target) (la_w_evar tl evar tl')
  | la_wl_cons wl' w => la_wl_cons (update_lowerbound_in_wl t wl' target) w
  end
.

Fixpoint update_upperbound_in_wl (t: la_type) (wl : la_worklist) (target : var) : la_worklist :=
  match wl with 
  | la_wl_nil => la_wl_nil
  | la_wl_cons wl' (la_w_evar tl evar tl') => 
    if (eq_dec target evar) 
      then la_wl_cons wl' (la_w_evar tl evar (la_tl_cons tl' t)) 
      else la_wl_cons (update_upperbound_in_wl t wl' target) (la_w_evar tl evar tl')
  | la_wl_cons wl' w => la_wl_cons (update_upperbound_in_wl t wl' target) w
  end
.

Fixpoint add_evar_before (v : var) (wl : la_worklist) (target : var) : la_worklist :=
  match wl with 
  | la_wl_nil => la_wl_nil
  | la_wl_cons wl' (la_w_evar tl evar tl') => 
    if (eq_dec target v) 
      then la_wl_cons (la_wl_cons wl' (la_w_evar la_tl_nil v la_tl_nil)) (la_w_evar tl evar tl') 
      else la_wl_cons (add_evar_before v wl' target) (la_w_evar tl evar tl')
  | la_wl_cons wl' w => la_wl_cons (add_evar_before v wl' target) w
  end
.

Fixpoint single_side_constraints_helper (t : la_type) (tl : la_typelist) : la_worklist := 
  match tl with
  | la_tl_nil => la_wl_nil
  | la_tl_cons tl' t' => la_wl_cons (single_side_constraints_helper t' tl') (la_w_sub t t')
  end
.

Definition single_side_constraints (tl : la_typelist) : la_worklist := 
  match tl with
  | la_tl_nil => la_wl_nil
  | la_tl_cons tl' t => single_side_constraints_helper t tl'
  end
.

Fixpoint double_side_constraints_helper (t : la_type) (tl : la_typelist) : la_worklist :=
  match tl with 
  | la_tl_nil => la_wl_nil
  | la_tl_cons tl' t' => la_wl_cons (double_side_constraints_helper t tl') (la_w_sub t t')
  end
.

Fixpoint double_side_constraints (tl1 tl2 : la_typelist) : la_worklist :=
  match tl1 with 
  | la_tl_nil => la_wl_nil
  | la_tl_cons tl1' t1 => wl_app (double_side_constraints tl1' tl2) (double_side_constraints_helper t1 tl2)
  end
.

Fixpoint wl_app_rev (wl1 wl2 : la_worklist) : la_worklist :=
  match wl2 with
  | la_wl_nil => wl1 
  | la_wl_cons wl2' w2 => wl_app_rev (la_wl_cons wl1 w2) wl2'
  end
.

Inductive reorder : la_worklist -> var -> la_type -> la_worklist -> la_worklist -> Prop :=
| re_stop : forall Γ x lbs ubs t Γ'
  , x `notin` fex_la_worklist Γ' `union` fex_la_type t
  -> reorder (la_wl_cons Γ (la_w_evar lbs x ubs)) x t la_wl_nil 
  (wl_app_rev (la_wl_cons Γ (la_w_evar lbs x ubs)) Γ')
| re_tx_stay : forall Γ1 Γ2 x y t Γ'
  , y `notin` ftx_la_worklist Γ' `union` ftx_la_type t
  -> reorder Γ1 x t Γ' Γ2
  -> reorder (la_wl_cons Γ1 (la_w_tvar y)) x t Γ' (la_wl_cons Γ2 (la_w_tvar y))
| re_ex_stay : forall Γ1 Γ2 y lbs ubs x t Γ'
  , y `notin` fex_la_worklist Γ' `union` fex_la_type t
  -> reorder Γ1 x t Γ' Γ2
  -> reorder (la_wl_cons Γ1 (la_w_evar lbs y ubs)) x t Γ' (la_wl_cons Γ2 (la_w_evar lbs y ubs))
| re_ex_move : forall Γ1 Γ2 y lbs ubs x t Γ'
  , x `notin` fex_la_typelist lbs `union` fex_la_typelist ubs
  -> reorder Γ1 x t (la_wl_cons Γ' (la_w_evar lbs y ubs)) Γ2
  -> reorder (la_wl_cons Γ1 (la_w_evar lbs y ubs)) x t Γ' (la_wl_cons Γ2 (la_w_evar lbs y ubs))
| re_sub_stay : forall Γ1 Γ2 t1 t2 x t Γ' y
  , y `in` fex_la_worklist Γ' `union` fex_la_type t -> y `notin` fex_la_type t1 `union` fex_la_type t2
  -> forall y, y `in` ftx_la_worklist Γ' `union` ftx_la_type t -> y `notin` ftx_la_type t1 `union` ftx_la_type t2
  -> reorder Γ1 x t Γ' Γ2
  -> reorder (la_wl_cons Γ1 (la_w_sub t1 t2)) x t Γ' (la_wl_cons Γ2 (la_w_sub t1 t2))
| re_sub_move : forall Γ1 Γ2 t1 t2 x t Γ'
  , (exists y, 
      ((y `in` fex_la_worklist Γ' `union` fex_la_type t) /\ (y `in` fex_la_type t1 `union` fex_la_type t2)) \/ 
      ((y `in` ftx_la_worklist Γ' `union` ftx_la_type t) /\ (y `in` ftx_la_type t1 `union` ftx_la_type t2)))
  -> reorder Γ1 x t (la_wl_cons Γ' (la_w_sub t1 t2)) Γ2
  -> reorder (la_wl_cons Γ1 (la_w_sub t1 t2)) x t Γ' (la_wl_cons Γ2 (la_w_sub t1 t2))
.

}}


defns
Monotype :: '' ::=

defn
mono t :: :: la_mono_type :: 'la_mono_'
by

----------------- :: tvar
mono tx

----------------- :: evar
mono ex

----------------- :: int
mono int

mono t1
mono t2
----------------- :: arrow
mono (t1 -> t2)

defns
NotForallType :: '' ::=

defn
~∀ A :: :: la_notforall_type :: 'la_nf_'
by

--------------- :: int
~∀ int

--------------- :: var
~∀ x

--------------- :: arrow
~∀ t1 -> t2


defns
InWorklist :: '' ::=

defn
t in wl :: :: la_in_worklist :: 'la_inwl_'
by

---------------------------- :: here_tvar
tx in wl , tx

tx in wl
---------------------------- :: there_tvar
tx in wl , w

---------------------------- :: here_evar
ex in wl , tl ≤ ex ≤ tl'

---------------------------- :: there_evar
ex in wl , w


defns
InScope :: '' ::=

defn
wl [ t1 ] [ t2 ] :: :: la_in_scope :: 'la_ins_'
by

t1 in wl
------------------------------------ :: here_var
wl , tx [t1] [tx]

t1 in wl
------------------------------------ :: here_evar
wl , tl ≤ ex ≤ tl' [ t1 ] [ ex ]

wl [ t1 ] [ t2 ]
------------------------------------ :: there_w
wl , w [ t1 ] [ t2 ]


defns 
AlgorithmeticSubtyping :: '' ::=

defn 
|- wl :: :: la_worklist_reducible :: 'la_wlred_'
by

tx notin wl
|- wl
---------------------------------------------------- :: tvar
|- wl , tx

ex notin wl
|- wl ++ < tl >
---------------------------------------------------- :: evar_nil_l
|- wl , tnil ≤ ex ≤ tl

|- wl ++ < tl' >
---------------------------------------------------- :: evar_nil_r
|- wl , tl ≤ ex ≤ tnil

|- wl ++ < tl * tl' >
---------------------------------------------------- :: evar
|- wl , tl ≤ ex ≤ tl'

|- wl
---------------------------------------------------- :: int_int
|- wl , int <: int

ex in wl
|- wl
---------------------------------------------------- :: tvar_tvar
|- wl , tx <: tx

ex in wl
|- wl
---------------------------------------------------- :: evar_evar
|- wl , ex <: ex

~∀ B
ex notin wl
|- wl , tnil ≤ ex ≤ tnil , [ ex / x ] A <: B
---------------------------------------------------- :: forall_l
|- wl , forall x. A <: B

tx notin wl 
|- wl , tx , [ tx / x ] A <: B
---------------------------------------------------- :: forall_r
|- wl , A <: forall x. B

|- wl , A2 <: B2 , B1 <: A1
---------------------------------------------------- :: arrow_arrow
|- wl , A1 -> A2 <: B1 -> B2

ex in wl
mono (A -> B)
+ { ex ∪ (A -> B) } wl -> wl'
|- wl'
---------------------------------------------------- :: evar_arrow_mono
|- wl , ex <: A -> B

ex in wl
mono (A -> B)
- { ex ∪ (A -> B) } wl -> wl'
|- wl' 
---------------------------------------------------- :: arrow_evar_mono
|- wl , A -> B <: ex

ex in wl
ex1 notin wl 
ex2 notin wl , tnil ≤ ex1 ≤ tnil
+ { ex ∪ (ex1 -> ex2) } wl, tnil ≤ ex1 ≤ tnil, tnil ≤ ex2 ≤ tnil -> wl'
|- wl', ex1 -> ex2 <: A -> B
---------------------------------------------------- :: evar_arrow
|- wl , ex <: A -> B

ex in wl
ex1 notin wl 
ex2 notin wl , tnil ≤ ex1 ≤ tnil
- { ex ∪ (ex1 -> ex2) } wl, tnil ≤ ex1 ≤ tnil, tnil ≤ ex2 ≤ tnil -> wl'
|- wl', A -> B <: ex1 -> ex2 
---------------------------------------------------- :: arrow_evar
|- wl , A -> B <: ex

wl [ey] [ex]
+ { ex ∪ ey } wl -> wl'
|- wl'
---------------------------------------------------- :: evar_evar_l
|- wl , ex <: ey

wl [ey] [ex]
- { ex ∪ ey } wl -> wl'
|- wl @ ey <+ ex
---------------------------------------------------- :: evar_evar_r
|- wl , ey <: ex

ex in wl
mono t 
- { ex ∪ t } wl -> wl'
|- wl'
---------------------------------------------------- :: mono_evar
|- wl , t <: ex

ex in wl
mono t 
+ { ex ∪ t } wl -> wl'
|- wl'
---------------------------------------------------- :: evar_mono
|- wl , ex <: t



