metavar typvar, X, Y, Z ::= {{ repr-locally-nameless }}
metavar expvar, x, y, z ::= {{ repr-locally-nameless }}

grammar

ftyp, T, S, U :: ftyp_ ::=
  | UNIT           ::   :: unit
  | X              ::   :: var
  | T1 -> T2       ::   :: arrow
  | ∀ X . T        ::   :: all  (+ bind X in T +)
  | T1 + T2        ::   :: sum
  | T1 × T2        ::   :: prod
  | ( T )          :: S :: paren {{ coq ([[T]]) }}
  | { T2 / X } T1  :: M :: subst {{ coq (open_ftyp_wrt_ftyp [[X T1]] [[T2]]) }}

fexp, e, f, g :: fexp_ ::=
  | unit                                ::   :: unit
  | x                                   ::   :: var
  | \ x : T . e                         ::   :: abs  (+ bind x in e +)
  | e1 e2                               ::   :: app
  | \ X . e                             ::   :: tabs (+ bind X in e +)
  | e @ T                               ::   :: tapp
%   | let x = e1 in e2                    ::   :: let (+ bind x in e2 +)
  | inl e                               ::   :: inl
  | inr e                               ::   :: inr
  | case e of inl x -> e2 | inr y -> e3 ::   :: case (+ bind x in e2 +) (+ bind y in e3 +)
  | proj1 e                             ::   :: proj1
  | proj2 e                             ::   :: proj2
  | < e1 , e2 >                         ::   :: pair
  | ( e )                               :: S :: paren  {{ coq ([[e]]) }}
  | { e2 / x } e1                       :: M :: subst1 {{ coq (open_fexp_wrt_fexp [[x e1]] [[e2]]) }}
  | { T2 / X } e1                       :: M :: subst2 {{ coq (open_fexp_wrt_ftyp [[X e1]] [[T2]]) }}

fbind, fb :: fbind_ ::=
  | : ▪  ::   :: tvar_empty
  | : T  ::   :: typ

substitutions
  single T X :: subst_typ_in
  single e x :: subst_exp_in

freevars
  T X :: fv_ftyp_in
  e x :: fv_fexp_in

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

fenv, E, F, G :: '' ::= {{ coq list (atom*fbind) }}
  | empty   ::   :: empty {{ coq nil }}
  | E , x fb ::   :: cons1 {{ coq ([[x]]~[[fb]] ++ [[E]]) }}
  | E , X fb ::   :: cons2 {{ coq ([[X]]~[[fb]] ++ [[E]]) }}

fvalue, v :: fvalue_ ::=
  | \ x : T . e  ::   :: abs  (+ bind x in e +)
  | \ X . e      ::   :: tabs (+ bind X in e +)
  | inl v        ::   :: inl
  | inr v        ::   :: inr
  | < v1 , v2 >  ::   :: pair

formula :: formula_ ::=
  | judgement       ::   :: judgement
  | ( x fb ) in E    ::   :: binds1 {{ coq binds ([[x]]) ([[fb]]) ([[E]]) }}
  | ( X fb ) in E    ::   :: binds2 {{ coq binds ([[X]]) ([[fb]]) ([[E]]) }}
  | uniq E          ::   :: uniq   {{ coq uniq ([[E]]) }}
  | x `notin` dom E ::   :: fresh1 {{ coq ([[x]] `notin` dom ([[E]])) }}
  | X `notin` dom E ::   :: fresh2 {{ coq ([[X]] `notin` dom ([[E]])) }}

subrules
  v <:: e

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
J_wf_typ :: '' ::=

defn
E |- T :: :: f_wf_typ :: 'f_wf_typ__' by

--------- :: unit
E |- UNIT

(X : ▪) in E
-------------- :: var
E |- X

E |- T1
E |- T2
-------------- :: arrow
E |- T1 -> T2

E, X : ▪ |- T
-------------------- :: all
E |- ∀ X . T

E |- T1
E |- T2
------------- :: sum
E |- T1 + T2

E |- T1
E |- T2
------------- :: prod
E |- T1 × T2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
J_f_wf_env :: '' ::=

defn
|- E :: :: f_wf_env :: 'f_wf_env__' by

--------- :: empty
|- empty

|- E
X `notin` dom E
---------------- :: sub
|- E , X : ▪

|- E
E |- T
x `notin` dom E
---------------- :: typ
|- E , x : T

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% defns
% Jsub :: '' ::=

% defn
% E |- T1 <: T2 :: :: sub :: 'sub_' by

% |- E
% E |- S
% -------------- :: top
% E |- S <: top

% |- E
% E |- X
% ------------ :: refl_tvar
% E |- X <: X

% E |- T1 <: S1
% E |- S2 <: T2
% -------------------------- :: arrow
% E |- S1 -> S2 <: T1 -> T2

% E, X |- T1 <: T2
% ---------------------------- :: all
% E |- ∀ X . T1 <: ∀ X . T2

% E |- S1 <: T1
% E |- S2 <: T2
% ------------------------ :: sum
% E |- S1 + S2 <: T1 + T2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
J_f_typing :: '' ::=

defn
E |- e : T :: :: f_typing :: 'f_typing__' by

---------------- :: unit
E |- unit : UNIT

|- E
(x:T) in E
----------- :: var
E |- x : T

E, x : T1 |- e : T2
--------------------------- :: abs
E |- \x : T1. e : T1 -> T2

E |- e1 : T1 -> T2
E |- e2 : T1
--------------------- :: app
E |- e1 e2 : T2

E, X : ▪ |- e : T
-------------------------- :: tabs
E |- \ X . e : ∀ X . T

E |- e1 : ∀ X . T1
--------------------------- :: tapp
E |- e1 @ T2 : {T2 / X} T1

% E |- e : S
% E |- S <: T
% ------------ :: sub
% E |- e : T

% E |- e1 : T1
% E, x : T1 |- e2 : T2
% --------------------------- :: let
% E |- let x = e1 in e2 : T2

E |- e1 : T1
E |- T2
---------------------- :: inl
E |- inl e1 : T1 + T2

E |- e1 : T2
E |- T1
---------------------- :: inr
E |- inr e1 : T1 + T2

E |- e1 : T1 + T2
E, x : T1 |- e2 : T
E, y : T2 |- e3 : T
---------------------------------------------- :: case
E |- case e1 of inl x -> e2 | inr y -> e3 : T

E |- e1 : T1
E |- e2 : T2
---------------------------------------------- :: pair
E |- < e1 , e2 > : T1 × T2

E |- e : T1 × T2
-------------------- :: proj1
E |- proj1 e : T1

E |- e : T1 × T2
-------------------- :: proj2
E |- proj2 e : T2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
J_f_exp_red :: '' ::=

defn
e1 --> e2 :: :: f_exp_red :: 'f_exp_red__' by

e1 --> e1'
----------------- :: app_1
e1 e2 --> e1' e2

e2 --> e2'
----------------- :: app_2
v1 e2 --> v1 e2'

e1 --> e1'
----------------------- :: tapp_1
e1 @ T --> e1' @ T

------------------------------- :: abs
(\x:T. e1) v2  --> {v2 / x} e1

------------------------------------ :: tabs
(\X . e1) @ T2  --> {T2 / X} e1

% e1 --> e1'
% --------------------------------------- :: let_1
% let x = e1 in e2 --> let x = e1' in e2

% --------------------------------- :: let
% let x = v1 in e2 --> {v1 / x} e2

e1 --> e1'
------------------- :: inl_1
inl e1 --> inl e1'

e1 --> e1'
------------------- :: inr_1
inr e1 --> inr e1'

e1 --> e1'
------------------------------------------------------------------------------- :: case_1
case e1 of inl x -> e2 | inr y -> e3 --> case e1' of inl x -> e2 | inr y -> e3

--------------------------------------------------------- :: case_inl
case inl v1 of inl x -> e2 | inr y -> e3 --> {v1 / x} e2

--------------------------------------------------------- :: case_inr
case inr v1 of inl x -> e2 | inr y -> e3 --> {v1 / y} e3

-------------------------------------- :: proj1_v
proj1 < v1 , v2 > --> v1

-------------------------------------- :: proj2_v
proj2 < v1 , v2 > --> v2

e --> e'
-------------------------------------- :: proj1
proj1 e --> proj1 e'

e --> e'
-------------------------------------- :: proj2
proj2 e --> proj2 e'

e1 --> e1'
-------------------------------------- :: pair1
< e1 , e2 > --> < e1' , e2 >

e2 --> e2'
-------------------------------------- :: pair2
< e1 , e2 > --> < e1 , e2' >