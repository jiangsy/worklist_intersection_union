metavar var, x, y, z ::= {{ repr-locally-nameless }}


grammar

ld_type, t, A, B :: 'ld_t_' ::= 
  | int           ::   :: int
  | forall x . t  ::   :: forall (+ bind x in t +)
  | t1 -> t2      ::   :: arrow
  | x             ::   :: var
  | ( t )         :: S :: paren {{ coq [[t]] }} 
  | [ t / x ] A   :: M :: susbt {{ coq (open_ld_type_wrt_ld_type [[x A]] [[t]]) }}


ld_worklist, wl :: 'ld_wl_' ::= 
  | nil            :: :: nil 
  | wl , x         :: :: cons_tvar
  | wl , t1 <: t2  :: :: cons_sub


formula :: formula_ ::=
  | judgement     ::   :: judgement
  | x notin wl    :: M :: ctx_fresh {{ coq ([[x]] `notin` wl_dom [[wl]]) }}


substitutions
  single ld_type x :: subst


freevars
  ld_type    x :: fv


embed {{ coq

Fixpoint wl_dom (wl : ld_worklist) : atoms :=
  match wl with
  | ld_wl_nil => {}
  | ld_wl_cons_tvar wl' x => add x (wl_dom wl')
  | ld_wl_cons_sub  wl' _ _  => wl_dom wl'
  end
.

}}


defns
Monotype :: '' ::=

defn
mono A :: :: ld_mono_type :: 'ld_mono_'
by

--------------- :: int
mono int

--------------- :: var
mono x

mono t1
mono t2
--------------- :: arrow
mono t1 -> t2

defns
NotForallType :: '' ::=

defn
!forall A :: :: ld_notforall_type :: 'ld_nf_'
by

--------------- :: int
!forall int

--------------- :: var
!forall x

--------------- :: arrow
!forall t1 -> t2


defns
InWorklist :: '' ::=

defn
x in wl :: :: ld_in_worklist :: 'ld_inwl_'
by

------------------ :: here
x in wl, x 

x in wl
------------------ :: there_tvar
x in wl, y 

x in wl
------------------ :: there_sub
x in wl, t1 <: t2

defns
WellFormedType :: '' ::=

defn
wl |=> t  :: :: ld_wf_type :: 'ld_wft_'
by

---------------- :: int
wl |=> int

x in wl
---------------- :: var
wl |=> x

wl |=> t1 
wl |=> t2 
---------------- :: arrow
wl |=> t1 -> t2


defns
DeclarativeSubtyping :: '' ::=

defn
|- wl :: :: ld_worklist_reducible :: 'ld_wlred_'
by

---------- :: nil
|- nil

x notin wl
|- wl
------------ :: cons_tvar
|- wl , x

|- wl
x in wl
------------------- :: var
|- wl , x <: x

|- wl
------------------- :: int
|- wl , int <: int
 
|- wl, B1 <: A1, A2 <: B2
--------------------------- :: arrow
|- wl , A1 -> A2 <: B1 -> B2

!forall B
wl |=> t
|- wl , [ t / x ] A <: B
------------------------- :: foralll
|- wl ,  forall x. A <: B

|- wl , x , A <: B
------------------- :: forallr
|- wl , A <: forall x. B



