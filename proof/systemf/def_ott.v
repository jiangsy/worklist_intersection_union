(* generated by Ott 0.32, locally-nameless lngen from: systemf/language.ott *)
Require Import Bool.
Require Import Metalib.Metatheory.
Require Import List.
(** syntax *)
Definition typvar : Set := var.
Definition expvar : Set := var.

Inductive ftyp : Set := 
 | ftyp_unit : ftyp
 | ftyp_var_b (_:nat)
 | ftyp_var_f (X:typvar)
 | ftyp_arrow (A1:ftyp) (A2:ftyp)
 | ftyp_all (A:ftyp)
 | ftyp_sum (A1:ftyp) (A2:ftyp)
 | ftyp_prod (A1:ftyp) (A2:ftyp).

Inductive fbind : Set := 
 | fbind_tvar_empty : fbind
 | fbind_typ (A:ftyp).

Inductive fexp : Set := 
 | fexp_unit : fexp
 | fexp_var_b (_:nat)
 | fexp_var_f (x:expvar)
 | fexp_abs (A:ftyp) (e:fexp)
 | fexp_app (e1:fexp) (e2:fexp)
 | fexp_tabs (e:fexp)
 | fexp_tapp (e:fexp) (A:ftyp)
 | fexp_inl (e:fexp)
 | fexp_inr (e:fexp)
 | fexp_case (e:fexp) (e2:fexp) (e3:fexp)
 | fexp_proj1 (e:fexp)
 | fexp_proj2 (e:fexp)
 | fexp_pair (e1:fexp) (e2:fexp).

Definition fenv : Set := list (atom*fbind).

(* EXPERIMENTAL *)
(** auxiliary functions on the new list types *)
(** library functions *)
(** subrules *)
Fixpoint is_fvalue_of_fexp (e_5:fexp) : bool :=
  match e_5 with
  | fexp_unit => false
  | (fexp_var_b nat) => false
  | (fexp_var_f x) => false
  | (fexp_abs A e) => (true)
  | (fexp_app e1 e2) => false
  | (fexp_tabs e) => (true)
  | (fexp_tapp e A) => false
  | (fexp_inl e) => ((is_fvalue_of_fexp e))
  | (fexp_inr e) => ((is_fvalue_of_fexp e))
  | (fexp_case e e2 e3) => false
  | (fexp_proj1 e) => false
  | (fexp_proj2 e) => false
  | (fexp_pair e1 e2) => ((is_fvalue_of_fexp e1) && (is_fvalue_of_fexp e2))
end.

(** arities *)
(** opening up abstractions *)
Fixpoint open_ftyp_wrt_ftyp_rec (k:nat) (A_5:ftyp) (A__6:ftyp) {struct A__6}: ftyp :=
  match A__6 with
  | ftyp_unit => ftyp_unit 
  | (ftyp_var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => ftyp_var_b nat
        | inleft (right _) => A_5
        | inright _ => ftyp_var_b (nat - 1)
      end
  | (ftyp_var_f X) => ftyp_var_f X
  | (ftyp_arrow A1 A2) => ftyp_arrow (open_ftyp_wrt_ftyp_rec k A_5 A1) (open_ftyp_wrt_ftyp_rec k A_5 A2)
  | (ftyp_all A) => ftyp_all (open_ftyp_wrt_ftyp_rec (S k) A_5 A)
  | (ftyp_sum A1 A2) => ftyp_sum (open_ftyp_wrt_ftyp_rec k A_5 A1) (open_ftyp_wrt_ftyp_rec k A_5 A2)
  | (ftyp_prod A1 A2) => ftyp_prod (open_ftyp_wrt_ftyp_rec k A_5 A1) (open_ftyp_wrt_ftyp_rec k A_5 A2)
end.

Fixpoint open_fexp_wrt_fexp_rec (k:nat) (e_5:fexp) (e__6:fexp) {struct e__6}: fexp :=
  match e__6 with
  | fexp_unit => fexp_unit 
  | (fexp_var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => fexp_var_b nat
        | inleft (right _) => e_5
        | inright _ => fexp_var_b (nat - 1)
      end
  | (fexp_var_f x) => fexp_var_f x
  | (fexp_abs A e) => fexp_abs A (open_fexp_wrt_fexp_rec (S k) e_5 e)
  | (fexp_app e1 e2) => fexp_app (open_fexp_wrt_fexp_rec k e_5 e1) (open_fexp_wrt_fexp_rec k e_5 e2)
  | (fexp_tabs e) => fexp_tabs (open_fexp_wrt_fexp_rec k e_5 e)
  | (fexp_tapp e A) => fexp_tapp (open_fexp_wrt_fexp_rec k e_5 e) A
  | (fexp_inl e) => fexp_inl (open_fexp_wrt_fexp_rec k e_5 e)
  | (fexp_inr e) => fexp_inr (open_fexp_wrt_fexp_rec k e_5 e)
  | (fexp_case e e2 e3) => fexp_case (open_fexp_wrt_fexp_rec k e_5 e) (open_fexp_wrt_fexp_rec (S k) e_5 e2) (open_fexp_wrt_fexp_rec (S k) e_5 e3)
  | (fexp_proj1 e) => fexp_proj1 (open_fexp_wrt_fexp_rec k e_5 e)
  | (fexp_proj2 e) => fexp_proj2 (open_fexp_wrt_fexp_rec k e_5 e)
  | (fexp_pair e1 e2) => fexp_pair (open_fexp_wrt_fexp_rec k e_5 e1) (open_fexp_wrt_fexp_rec k e_5 e2)
end.

Fixpoint open_fexp_wrt_ftyp_rec (k:nat) (A_5:ftyp) (e_5:fexp) {struct e_5}: fexp :=
  match e_5 with
  | fexp_unit => fexp_unit 
  | (fexp_var_b nat) => fexp_var_b nat
  | (fexp_var_f x) => fexp_var_f x
  | (fexp_abs A e) => fexp_abs (open_ftyp_wrt_ftyp_rec k A_5 A) (open_fexp_wrt_ftyp_rec k A_5 e)
  | (fexp_app e1 e2) => fexp_app (open_fexp_wrt_ftyp_rec k A_5 e1) (open_fexp_wrt_ftyp_rec k A_5 e2)
  | (fexp_tabs e) => fexp_tabs (open_fexp_wrt_ftyp_rec (S k) A_5 e)
  | (fexp_tapp e A) => fexp_tapp (open_fexp_wrt_ftyp_rec k A_5 e) (open_ftyp_wrt_ftyp_rec k A_5 A)
  | (fexp_inl e) => fexp_inl (open_fexp_wrt_ftyp_rec k A_5 e)
  | (fexp_inr e) => fexp_inr (open_fexp_wrt_ftyp_rec k A_5 e)
  | (fexp_case e e2 e3) => fexp_case (open_fexp_wrt_ftyp_rec k A_5 e) (open_fexp_wrt_ftyp_rec k A_5 e2) (open_fexp_wrt_ftyp_rec k A_5 e3)
  | (fexp_proj1 e) => fexp_proj1 (open_fexp_wrt_ftyp_rec k A_5 e)
  | (fexp_proj2 e) => fexp_proj2 (open_fexp_wrt_ftyp_rec k A_5 e)
  | (fexp_pair e1 e2) => fexp_pair (open_fexp_wrt_ftyp_rec k A_5 e1) (open_fexp_wrt_ftyp_rec k A_5 e2)
end.

Definition open_fbind_wrt_ftyp_rec (k:nat) (A5:ftyp) (fb5:fbind) : fbind :=
  match fb5 with
  | fbind_tvar_empty => fbind_tvar_empty 
  | (fbind_typ A) => fbind_typ (open_ftyp_wrt_ftyp_rec k A5 A)
end.

Definition open_fexp_wrt_fexp e_5 e__6 := open_fexp_wrt_fexp_rec 0 e__6 e_5.

Definition open_fexp_wrt_ftyp A_5 e_5 := open_fexp_wrt_ftyp_rec 0 e_5 A_5.

Definition open_ftyp_wrt_ftyp A_5 A__6 := open_ftyp_wrt_ftyp_rec 0 A__6 A_5.

Definition open_fbind_wrt_ftyp A5 fb5 := open_fbind_wrt_ftyp_rec 0 fb5 A5.

(** closing up abstractions *)
Fixpoint close_ftyp_wrt_ftyp_rec (k:nat) (A_5:var) (A__6:ftyp) {struct A__6}: ftyp :=
  match A__6 with
  | ftyp_unit => ftyp_unit 
  | (ftyp_var_b nat) => 
       if (lt_dec nat k) 
         then ftyp_var_b nat
         else ftyp_var_b (S nat)
  | (ftyp_var_f X) => if (A_5 === X) then (ftyp_var_b k) else (ftyp_var_f X)
  | (ftyp_arrow A1 A2) => ftyp_arrow (close_ftyp_wrt_ftyp_rec k A_5 A1) (close_ftyp_wrt_ftyp_rec k A_5 A2)
  | (ftyp_all A) => ftyp_all (close_ftyp_wrt_ftyp_rec (S k) A_5 A)
  | (ftyp_sum A1 A2) => ftyp_sum (close_ftyp_wrt_ftyp_rec k A_5 A1) (close_ftyp_wrt_ftyp_rec k A_5 A2)
  | (ftyp_prod A1 A2) => ftyp_prod (close_ftyp_wrt_ftyp_rec k A_5 A1) (close_ftyp_wrt_ftyp_rec k A_5 A2)
end.

Definition close_fbind_wrt_ftyp_rec (k:nat) (A5:var) (fb5:fbind) : fbind :=
  match fb5 with
  | fbind_tvar_empty => fbind_tvar_empty 
  | (fbind_typ A) => fbind_typ (close_ftyp_wrt_ftyp_rec k A5 A)
end.

Fixpoint close_fexp_wrt_fexp_rec (k:nat) (e_5:var) (e__6:fexp) {struct e__6}: fexp :=
  match e__6 with
  | fexp_unit => fexp_unit 
  | (fexp_var_b nat) => 
       if (lt_dec nat k) 
         then fexp_var_b nat
         else fexp_var_b (S nat)
  | (fexp_var_f x) => if (e_5 === x) then (fexp_var_b k) else (fexp_var_f x)
  | (fexp_abs A e) => fexp_abs A (close_fexp_wrt_fexp_rec (S k) e_5 e)
  | (fexp_app e1 e2) => fexp_app (close_fexp_wrt_fexp_rec k e_5 e1) (close_fexp_wrt_fexp_rec k e_5 e2)
  | (fexp_tabs e) => fexp_tabs (close_fexp_wrt_fexp_rec k e_5 e)
  | (fexp_tapp e A) => fexp_tapp (close_fexp_wrt_fexp_rec k e_5 e) A
  | (fexp_inl e) => fexp_inl (close_fexp_wrt_fexp_rec k e_5 e)
  | (fexp_inr e) => fexp_inr (close_fexp_wrt_fexp_rec k e_5 e)
  | (fexp_case e e2 e3) => fexp_case (close_fexp_wrt_fexp_rec k e_5 e) (close_fexp_wrt_fexp_rec (S k) e_5 e2) (close_fexp_wrt_fexp_rec (S k) e_5 e3)
  | (fexp_proj1 e) => fexp_proj1 (close_fexp_wrt_fexp_rec k e_5 e)
  | (fexp_proj2 e) => fexp_proj2 (close_fexp_wrt_fexp_rec k e_5 e)
  | (fexp_pair e1 e2) => fexp_pair (close_fexp_wrt_fexp_rec k e_5 e1) (close_fexp_wrt_fexp_rec k e_5 e2)
end.

Fixpoint close_fexp_wrt_ftyp_rec (k:nat) (A_5:var) (e_5:fexp) {struct e_5}: fexp :=
  match e_5 with
  | fexp_unit => fexp_unit 
  | (fexp_var_b nat) => fexp_var_b nat
  | (fexp_var_f x) => fexp_var_f x
  | (fexp_abs A e) => fexp_abs (close_ftyp_wrt_ftyp_rec k A_5 A) (close_fexp_wrt_ftyp_rec k A_5 e)
  | (fexp_app e1 e2) => fexp_app (close_fexp_wrt_ftyp_rec k A_5 e1) (close_fexp_wrt_ftyp_rec k A_5 e2)
  | (fexp_tabs e) => fexp_tabs (close_fexp_wrt_ftyp_rec (S k) A_5 e)
  | (fexp_tapp e A) => fexp_tapp (close_fexp_wrt_ftyp_rec k A_5 e) (close_ftyp_wrt_ftyp_rec k A_5 A)
  | (fexp_inl e) => fexp_inl (close_fexp_wrt_ftyp_rec k A_5 e)
  | (fexp_inr e) => fexp_inr (close_fexp_wrt_ftyp_rec k A_5 e)
  | (fexp_case e e2 e3) => fexp_case (close_fexp_wrt_ftyp_rec k A_5 e) (close_fexp_wrt_ftyp_rec k A_5 e2) (close_fexp_wrt_ftyp_rec k A_5 e3)
  | (fexp_proj1 e) => fexp_proj1 (close_fexp_wrt_ftyp_rec k A_5 e)
  | (fexp_proj2 e) => fexp_proj2 (close_fexp_wrt_ftyp_rec k A_5 e)
  | (fexp_pair e1 e2) => fexp_pair (close_fexp_wrt_ftyp_rec k A_5 e1) (close_fexp_wrt_ftyp_rec k A_5 e2)
end.

Definition close_fbind_wrt_ftyp fb5 A5 := close_fbind_wrt_ftyp_rec 0 fb5 A5.

Definition close_fexp_wrt_fexp e__6 e_5 := close_fexp_wrt_fexp_rec 0 e__6 e_5.

Definition close_fexp_wrt_ftyp e_5 A_5 := close_fexp_wrt_ftyp_rec 0 e_5 A_5.

Definition close_ftyp_wrt_ftyp A__6 A_5 := close_ftyp_wrt_ftyp_rec 0 A__6 A_5.

(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_ftyp *)
Inductive lc_ftyp : ftyp -> Prop :=    (* defn lc_ftyp *)
 | lc_ftyp_unit : 
     (lc_ftyp ftyp_unit)
 | lc_ftyp_var_f : forall (X:typvar),
     (lc_ftyp (ftyp_var_f X))
 | lc_ftyp_arrow : forall (A1 A2:ftyp),
     (lc_ftyp A1) ->
     (lc_ftyp A2) ->
     (lc_ftyp (ftyp_arrow A1 A2))
 | lc_ftyp_all : forall (A:ftyp),
      ( forall X , lc_ftyp  ( open_ftyp_wrt_ftyp A (ftyp_var_f X) )  )  ->
     (lc_ftyp (ftyp_all A))
 | lc_ftyp_sum : forall (A1 A2:ftyp),
     (lc_ftyp A1) ->
     (lc_ftyp A2) ->
     (lc_ftyp (ftyp_sum A1 A2))
 | lc_ftyp_prod : forall (A1 A2:ftyp),
     (lc_ftyp A1) ->
     (lc_ftyp A2) ->
     (lc_ftyp (ftyp_prod A1 A2)).

(* defns LC_fbind *)
Inductive lc_fbind : fbind -> Prop :=    (* defn lc_fbind *)
 | lc_fbind_tvar_empty : 
     (lc_fbind fbind_tvar_empty)
 | lc_fbind_typ : forall (A:ftyp),
     (lc_ftyp A) ->
     (lc_fbind (fbind_typ A)).

(* defns LC_fexp *)
Inductive lc_fexp : fexp -> Prop :=    (* defn lc_fexp *)
 | lc_fexp_unit : 
     (lc_fexp fexp_unit)
 | lc_fexp_var_f : forall (x:expvar),
     (lc_fexp (fexp_var_f x))
 | lc_fexp_abs : forall (A:ftyp) (e:fexp),
     (lc_ftyp A) ->
      ( forall x , lc_fexp  ( open_fexp_wrt_fexp e (fexp_var_f x) )  )  ->
     (lc_fexp (fexp_abs A e))
 | lc_fexp_app : forall (e1 e2:fexp),
     (lc_fexp e1) ->
     (lc_fexp e2) ->
     (lc_fexp (fexp_app e1 e2))
 | lc_fexp_tabs : forall (e:fexp),
      ( forall X , lc_fexp  ( open_fexp_wrt_ftyp e (ftyp_var_f X) )  )  ->
     (lc_fexp (fexp_tabs e))
 | lc_fexp_tapp : forall (e:fexp) (A:ftyp),
     (lc_fexp e) ->
     (lc_ftyp A) ->
     (lc_fexp (fexp_tapp e A))
 | lc_fexp_inl : forall (e:fexp),
     (lc_fexp e) ->
     (lc_fexp (fexp_inl e))
 | lc_fexp_inr : forall (e:fexp),
     (lc_fexp e) ->
     (lc_fexp (fexp_inr e))
 | lc_fexp_case : forall (e e2 e3:fexp),
     (lc_fexp e) ->
      ( forall x , lc_fexp  ( open_fexp_wrt_fexp e2 (fexp_var_f x) )  )  ->
      ( forall y , lc_fexp  ( open_fexp_wrt_fexp e3 (fexp_var_f y) )  )  ->
     (lc_fexp (fexp_case e e2 e3))
 | lc_fexp_proj1 : forall (e:fexp),
     (lc_fexp e) ->
     (lc_fexp (fexp_proj1 e))
 | lc_fexp_proj2 : forall (e:fexp),
     (lc_fexp e) ->
     (lc_fexp (fexp_proj2 e))
 | lc_fexp_pair : forall (e1 e2:fexp),
     (lc_fexp e1) ->
     (lc_fexp e2) ->
     (lc_fexp (fexp_pair e1 e2)).
(** free variables *)
Fixpoint ftvar_in_ftyp (A_5:ftyp) : vars :=
  match A_5 with
  | ftyp_unit => {}
  | (ftyp_var_b nat) => {}
  | (ftyp_var_f X) => {{X}}
  | (ftyp_arrow A1 A2) => (ftvar_in_ftyp A1) \u (ftvar_in_ftyp A2)
  | (ftyp_all A) => (ftvar_in_ftyp A)
  | (ftyp_sum A1 A2) => (ftvar_in_ftyp A1) \u (ftvar_in_ftyp A2)
  | (ftyp_prod A1 A2) => (ftvar_in_ftyp A1) \u (ftvar_in_ftyp A2)
end.

Definition ftvar_in_fbind (fb5:fbind) : vars :=
  match fb5 with
  | fbind_tvar_empty => {}
  | (fbind_typ A) => (ftvar_in_ftyp A)
end.

Fixpoint fvar_in_fexp (e_5:fexp) : vars :=
  match e_5 with
  | fexp_unit => {}
  | (fexp_var_b nat) => {}
  | (fexp_var_f x) => {{x}}
  | (fexp_abs A e) => (fvar_in_fexp e)
  | (fexp_app e1 e2) => (fvar_in_fexp e1) \u (fvar_in_fexp e2)
  | (fexp_tabs e) => (fvar_in_fexp e)
  | (fexp_tapp e A) => (fvar_in_fexp e)
  | (fexp_inl e) => (fvar_in_fexp e)
  | (fexp_inr e) => (fvar_in_fexp e)
  | (fexp_case e e2 e3) => (fvar_in_fexp e) \u (fvar_in_fexp e2) \u (fvar_in_fexp e3)
  | (fexp_proj1 e) => (fvar_in_fexp e)
  | (fexp_proj2 e) => (fvar_in_fexp e)
  | (fexp_pair e1 e2) => (fvar_in_fexp e1) \u (fvar_in_fexp e2)
end.

Fixpoint ftvar_in_fexp (e_5:fexp) : vars :=
  match e_5 with
  | fexp_unit => {}
  | (fexp_var_b nat) => {}
  | (fexp_var_f x) => {}
  | (fexp_abs A e) => (ftvar_in_ftyp A) \u (ftvar_in_fexp e)
  | (fexp_app e1 e2) => (ftvar_in_fexp e1) \u (ftvar_in_fexp e2)
  | (fexp_tabs e) => (ftvar_in_fexp e)
  | (fexp_tapp e A) => (ftvar_in_fexp e) \u (ftvar_in_ftyp A)
  | (fexp_inl e) => (ftvar_in_fexp e)
  | (fexp_inr e) => (ftvar_in_fexp e)
  | (fexp_case e e2 e3) => (ftvar_in_fexp e) \u (ftvar_in_fexp e2) \u (ftvar_in_fexp e3)
  | (fexp_proj1 e) => (ftvar_in_fexp e)
  | (fexp_proj2 e) => (ftvar_in_fexp e)
  | (fexp_pair e1 e2) => (ftvar_in_fexp e1) \u (ftvar_in_fexp e2)
end.

(** substitutions *)
Fixpoint subst_typ_in_ftyp (A_5:ftyp) (X5:typvar) (A__6:ftyp) {struct A__6} : ftyp :=
  match A__6 with
  | ftyp_unit => ftyp_unit 
  | (ftyp_var_b nat) => ftyp_var_b nat
  | (ftyp_var_f X) => (if eq_var X X5 then A_5 else (ftyp_var_f X))
  | (ftyp_arrow A1 A2) => ftyp_arrow (subst_typ_in_ftyp A_5 X5 A1) (subst_typ_in_ftyp A_5 X5 A2)
  | (ftyp_all A) => ftyp_all (subst_typ_in_ftyp A_5 X5 A)
  | (ftyp_sum A1 A2) => ftyp_sum (subst_typ_in_ftyp A_5 X5 A1) (subst_typ_in_ftyp A_5 X5 A2)
  | (ftyp_prod A1 A2) => ftyp_prod (subst_typ_in_ftyp A_5 X5 A1) (subst_typ_in_ftyp A_5 X5 A2)
end.

Definition subst_typ_in_fbind (A5:ftyp) (X5:typvar) (fb5:fbind) : fbind :=
  match fb5 with
  | fbind_tvar_empty => fbind_tvar_empty 
  | (fbind_typ A) => fbind_typ (subst_typ_in_ftyp A5 X5 A)
end.

Fixpoint subst_exp_in_fexp (e_5:fexp) (x5:expvar) (e__6:fexp) {struct e__6} : fexp :=
  match e__6 with
  | fexp_unit => fexp_unit 
  | (fexp_var_b nat) => fexp_var_b nat
  | (fexp_var_f x) => (if eq_var x x5 then e_5 else (fexp_var_f x))
  | (fexp_abs A e) => fexp_abs A (subst_exp_in_fexp e_5 x5 e)
  | (fexp_app e1 e2) => fexp_app (subst_exp_in_fexp e_5 x5 e1) (subst_exp_in_fexp e_5 x5 e2)
  | (fexp_tabs e) => fexp_tabs (subst_exp_in_fexp e_5 x5 e)
  | (fexp_tapp e A) => fexp_tapp (subst_exp_in_fexp e_5 x5 e) A
  | (fexp_inl e) => fexp_inl (subst_exp_in_fexp e_5 x5 e)
  | (fexp_inr e) => fexp_inr (subst_exp_in_fexp e_5 x5 e)
  | (fexp_case e e2 e3) => fexp_case (subst_exp_in_fexp e_5 x5 e) (subst_exp_in_fexp e_5 x5 e2) (subst_exp_in_fexp e_5 x5 e3)
  | (fexp_proj1 e) => fexp_proj1 (subst_exp_in_fexp e_5 x5 e)
  | (fexp_proj2 e) => fexp_proj2 (subst_exp_in_fexp e_5 x5 e)
  | (fexp_pair e1 e2) => fexp_pair (subst_exp_in_fexp e_5 x5 e1) (subst_exp_in_fexp e_5 x5 e2)
end.

Fixpoint subst_typ_in_fexp (A_5:ftyp) (X5:typvar) (e_5:fexp) {struct e_5} : fexp :=
  match e_5 with
  | fexp_unit => fexp_unit 
  | (fexp_var_b nat) => fexp_var_b nat
  | (fexp_var_f x) => fexp_var_f x
  | (fexp_abs A e) => fexp_abs (subst_typ_in_ftyp A_5 X5 A) (subst_typ_in_fexp A_5 X5 e)
  | (fexp_app e1 e2) => fexp_app (subst_typ_in_fexp A_5 X5 e1) (subst_typ_in_fexp A_5 X5 e2)
  | (fexp_tabs e) => fexp_tabs (subst_typ_in_fexp A_5 X5 e)
  | (fexp_tapp e A) => fexp_tapp (subst_typ_in_fexp A_5 X5 e) (subst_typ_in_ftyp A_5 X5 A)
  | (fexp_inl e) => fexp_inl (subst_typ_in_fexp A_5 X5 e)
  | (fexp_inr e) => fexp_inr (subst_typ_in_fexp A_5 X5 e)
  | (fexp_case e e2 e3) => fexp_case (subst_typ_in_fexp A_5 X5 e) (subst_typ_in_fexp A_5 X5 e2) (subst_typ_in_fexp A_5 X5 e3)
  | (fexp_proj1 e) => fexp_proj1 (subst_typ_in_fexp A_5 X5 e)
  | (fexp_proj2 e) => fexp_proj2 (subst_typ_in_fexp A_5 X5 e)
  | (fexp_pair e1 e2) => fexp_pair (subst_typ_in_fexp A_5 X5 e1) (subst_typ_in_fexp A_5 X5 e2)
end.


(** definitions *)

(* defns J_wf_typ *)
Inductive f_wf_typ : fenv -> ftyp -> Prop :=    (* defn f_wf_typ *)
 | f_wf_typ__unit : forall (Δ:fenv),
     f_wf_typ Δ ftyp_unit
 | f_wf_typ__tvar : forall (Δ:fenv) (X:typvar),
      binds ( X ) ( fbind_tvar_empty ) ( Δ )  ->
     f_wf_typ Δ (ftyp_var_f X)
 | f_wf_typ__arrow : forall (Δ:fenv) (A1 A2:ftyp),
     f_wf_typ Δ A1 ->
     f_wf_typ Δ A2 ->
     f_wf_typ Δ (ftyp_arrow A1 A2)
 | f_wf_typ__all : forall (L:vars) (Δ:fenv) (A:ftyp),
      ( forall X , X \notin  L  -> f_wf_typ  ( X ~ fbind_tvar_empty  ++  Δ )   ( open_ftyp_wrt_ftyp A (ftyp_var_f X) )  )  ->
     f_wf_typ Δ (ftyp_all A)
 | f_wf_typ__sum : forall (Δ:fenv) (A1 A2:ftyp),
     f_wf_typ Δ A1 ->
     f_wf_typ Δ A2 ->
     f_wf_typ Δ (ftyp_sum A1 A2)
 | f_wf_typ__prod : forall (Δ:fenv) (A1 A2:ftyp),
     f_wf_typ Δ A1 ->
     f_wf_typ Δ A2 ->
     f_wf_typ Δ (ftyp_prod A1 A2).

(* defns J_f_wf_env *)
Inductive f_wf_env : fenv -> Prop :=    (* defn f_wf_env *)
 | f_wf_env__empty : 
     f_wf_env  nil 
 | f_wf_env__sub : forall (Δ:fenv) (X:typvar),
     f_wf_env Δ ->
      ( X  `notin` dom ( Δ ))  ->
     f_wf_env  ( X ~ fbind_tvar_empty  ++  Δ ) 
 | f_wf_env__typ : forall (Δ:fenv) (x:expvar) (A:ftyp),
     f_wf_env Δ ->
     f_wf_typ Δ A ->
      ( x  `notin` dom ( Δ ))  ->
     f_wf_env  ( x ~ (fbind_typ A)  ++  Δ ) .

(* defns J_f_typing *)
Inductive f_typing : fenv -> fexp -> ftyp -> Prop :=    (* defn f_typing *)
 | f_typing__unit : forall (Δ:fenv),
     f_typing Δ fexp_unit ftyp_unit
 | f_typing__var : forall (Δ:fenv) (x:expvar) (A:ftyp),
     f_wf_env Δ ->
      binds ( x ) ( (fbind_typ A) ) ( Δ )  ->
     f_typing Δ (fexp_var_f x) A
 | f_typing__abs : forall (L:vars) (Δ:fenv) (A1:ftyp) (e:fexp) (A2:ftyp),
      ( forall x , x \notin  L  -> f_typing  ( x ~ (fbind_typ A1)  ++  Δ )   ( open_fexp_wrt_fexp e (fexp_var_f x) )  A2 )  ->
     f_typing Δ (fexp_abs A1 e) (ftyp_arrow A1 A2)
 | f_typing__app : forall (Δ:fenv) (e1 e2:fexp) (A2 A1:ftyp),
     f_typing Δ e1 (ftyp_arrow A1 A2) ->
     f_typing Δ e2 A1 ->
     f_typing Δ (fexp_app e1 e2) A2
 | f_typing__tabs : forall (L:vars) (Δ:fenv) (e:fexp) (A:ftyp),
      ( forall X , X \notin  L  -> f_typing  ( X ~ fbind_tvar_empty  ++  Δ )   ( open_fexp_wrt_ftyp e (ftyp_var_f X) )   ( open_ftyp_wrt_ftyp A (ftyp_var_f X) )  )  ->
     f_typing Δ (fexp_tabs e) (ftyp_all A)
 | f_typing__tapp : forall (Δ:fenv) (e1:fexp) (A2 A1:ftyp),
     lc_ftyp A2 ->
     f_typing Δ e1 (ftyp_all A1) ->
     f_typing Δ (fexp_tapp e1 A2)  (open_ftyp_wrt_ftyp  A1   A2 ) 
 | f_typing__inl : forall (Δ:fenv) (e1:fexp) (A1 A2:ftyp),
     f_typing Δ e1 A1 ->
     f_wf_typ Δ A2 ->
     f_typing Δ (fexp_inl e1) (ftyp_sum A1 A2)
 | f_typing__inr : forall (Δ:fenv) (e1:fexp) (A1 A2:ftyp),
     f_typing Δ e1 A2 ->
     f_wf_typ Δ A1 ->
     f_typing Δ (fexp_inr e1) (ftyp_sum A1 A2)
 | f_typing__case : forall (L:vars) (Δ:fenv) (e1 e2 e3:fexp) (A A1 A2:ftyp),
     f_typing Δ e1 (ftyp_sum A1 A2) ->
      ( forall x , x \notin  L  -> f_typing  ( x ~ (fbind_typ A1)  ++  Δ )   ( open_fexp_wrt_fexp e2 (fexp_var_f x) )  A )  ->
      ( forall y , y \notin  L  -> f_typing  ( y ~ (fbind_typ A2)  ++  Δ )   ( open_fexp_wrt_fexp e3 (fexp_var_f y) )  A )  ->
     f_typing Δ (fexp_case e1 e2 e3) A
 | f_typing__pair : forall (Δ:fenv) (e1 e2:fexp) (A1 A2:ftyp),
     f_typing Δ e1 A1 ->
     f_typing Δ e2 A2 ->
     f_typing Δ (fexp_pair e1 e2) (ftyp_prod A1 A2)
 | f_typing__proj1 : forall (Δ:fenv) (e:fexp) (A1 A2:ftyp),
     f_typing Δ e (ftyp_prod A1 A2) ->
     f_typing Δ (fexp_proj1 e) A1
 | f_typing__proj2 : forall (Δ:fenv) (e:fexp) (A2 A1:ftyp),
     f_typing Δ e (ftyp_prod A1 A2) ->
     f_typing Δ (fexp_proj2 e) A2.

(* defns J_f_exp_red *)
Inductive f_exp_red : fexp -> fexp -> Prop :=    (* defn f_exp_red *)
 | f_exp_red__app_1 : forall (e1 e2 e1':fexp),
     lc_fexp e2 ->
     f_exp_red e1 e1' ->
     f_exp_red (fexp_app e1 e2) (fexp_app e1' e2)
 | f_exp_red__app_2 : forall (e2 e2' v1:fexp),
     Is_true (is_fvalue_of_fexp v1) ->
     lc_fexp v1 ->
     f_exp_red e2 e2' ->
     f_exp_red (fexp_app v1 e2) (fexp_app v1 e2')
 | f_exp_red__tapp_1 : forall (e1:fexp) (A:ftyp) (e1':fexp),
     lc_ftyp A ->
     f_exp_red e1 e1' ->
     f_exp_red (fexp_tapp e1 A) (fexp_tapp e1' A)
 | f_exp_red__abs : forall (A:ftyp) (e1 v2:fexp),
     Is_true (is_fvalue_of_fexp v2) ->
     lc_ftyp A ->
     lc_fexp (fexp_abs A e1) ->
     lc_fexp v2 ->
     f_exp_red (fexp_app  ( (fexp_abs A e1) )  v2)  (open_fexp_wrt_fexp  e1   v2 ) 
 | f_exp_red__tabs : forall (e1:fexp) (A2:ftyp),
     lc_fexp (fexp_tabs e1) ->
     lc_ftyp A2 ->
     f_exp_red (fexp_tapp  ( (fexp_tabs e1) )  A2)  (open_fexp_wrt_ftyp  e1   A2 ) 
 | f_exp_red__inl_1 : forall (e1 e1':fexp),
     f_exp_red e1 e1' ->
     f_exp_red (fexp_inl e1) (fexp_inl e1')
 | f_exp_red__inr_1 : forall (e1 e1':fexp),
     f_exp_red e1 e1' ->
     f_exp_red (fexp_inr e1) (fexp_inr e1')
 | f_exp_red__case_1 : forall (e1 e2 e3 e1':fexp),
     lc_fexp (fexp_case e1 e2 e3) ->
     lc_fexp (fexp_case e1 e2 e3) ->
     f_exp_red e1 e1' ->
     f_exp_red (fexp_case e1 e2 e3) (fexp_case e1' e2 e3)
 | f_exp_red__case_inl : forall (e2 e3 v1:fexp),
     Is_true (is_fvalue_of_fexp v1) ->
     lc_fexp (fexp_case (fexp_inl v1) e2 e3) ->
     lc_fexp (fexp_case (fexp_inl v1) e2 e3) ->
     lc_fexp v1 ->
     f_exp_red (fexp_case (fexp_inl v1) e2 e3)  (open_fexp_wrt_fexp  e2   v1 ) 
 | f_exp_red__case_inr : forall (e2 e3 v1:fexp),
     Is_true (is_fvalue_of_fexp v1) ->
     lc_fexp (fexp_case (fexp_inr v1) e2 e3) ->
     lc_fexp (fexp_case (fexp_inr v1) e2 e3) ->
     lc_fexp v1 ->
     f_exp_red (fexp_case (fexp_inr v1) e2 e3)  (open_fexp_wrt_fexp  e3   v1 ) 
 | f_exp_red__proj1_v : forall (v2 v1:fexp),
     Is_true (is_fvalue_of_fexp v1) ->
     Is_true (is_fvalue_of_fexp v2) ->
     lc_fexp v2 ->
     lc_fexp v1 ->
     f_exp_red (fexp_proj1 (fexp_pair v1 v2)) v1
 | f_exp_red__proj2_v : forall (v1 v2:fexp),
     Is_true (is_fvalue_of_fexp v1) ->
     Is_true (is_fvalue_of_fexp v2) ->
     lc_fexp v1 ->
     lc_fexp v2 ->
     f_exp_red (fexp_proj2 (fexp_pair v1 v2)) v2
 | f_exp_red__proj1 : forall (e e':fexp),
     f_exp_red e e' ->
     f_exp_red (fexp_proj1 e) (fexp_proj1 e')
 | f_exp_red__proj2 : forall (e e':fexp),
     f_exp_red e e' ->
     f_exp_red (fexp_proj2 e) (fexp_proj2 e')
 | f_exp_red__pair1 : forall (e1 e2 e1':fexp),
     lc_fexp e2 ->
     f_exp_red e1 e1' ->
     f_exp_red (fexp_pair e1 e2) (fexp_pair e1' e2)
 | f_exp_red__pair2 : forall (e1 e2 e2':fexp),
     lc_fexp e1 ->
     f_exp_red e2 e2' ->
     f_exp_red (fexp_pair e1 e2) (fexp_pair e1 e2').


(** infrastructure *)
#[export] Hint Constructors f_wf_typ f_wf_env f_typing f_exp_red lc_ftyp lc_fbind lc_fexp : core.


