
metavar x, y, z ::= {{ repr-locally-nameless }}
indexvar index, i, j, n, m ::= {{ coq nat }} 


grammar

type, t, A, B :: 'la_t_' ::= 
  | int :: :: int
  | forall x . t :: :: forall (+ bind x in t +) 
  | t1 -> t2 :: :: arrow 
  | x :: :: tvar
  | ^ x :: :: existential_tvar
  | ( t )         :: S :: paren {{ coq ([[t]]) }}
  % used in introducing existential variables only
  | [ t1 / x ] t2 :: M :: subst {{ coq (type_subst_type [[t1]] [[x]] [[t2]])}}

var, v :: 'la_var_' ::=
  | x   ::  :: tvar
  | ^ x ::  :: existential_tvar

work, w :: 'la_w_' ::=
  | t1 <: t2 :: :: subtyp

bind, b :: 'la_b_' ::=
  | x :: :: tvar
  | { t1 , .. , tn } <: ^ x <: { t'1 , .. , t'm } :: :: extvar

worklist, wl :: 'la_wl_' ::= 
  | nil    :: :: nil 
  | wl |- w :: :: cons 
  | wl , b :: :: bind
 
subrules 
  var <:: type

freevars
  type    x :: fv

substitutions
  single type x :: subst  


defns
Monotype :: '' ::=

defn
mono t :: :: mono_type :: 'la_mono_'
by

----------- :: tvar
mono x

----------- :: texvar
mono ( ^ x )

------------- :: int
mono int

mono t1
mono t2
----------------- :: arrow
mono (t1 -> t2)


defns 
AlgorithmeticSubtyping :: '' ::=

defn 
|- wl :: :: wf_worklist :: 'la_wf_wl_'
by

---------- :: nil
|- nil


|- wl
wl |- w
---------- :: cons
|- wl , w

defn 
wl |- w :: :: judge_worklist :: 'la_jdg_wl_'
by

------------ :: var
wl |- x

------------ :: sub_int
wl |- int <: int

------------ :: sub_tvar
wl |- x <: x


wl |- A2 <: B2 
wl , A2 <: B2 |- B1 <: A1
--------------------------- :: sub_arrow
wl |- A1 -> A2 <: B1 -> B2
