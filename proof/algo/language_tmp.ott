
metavar x, y, z ::= {{ repr-locally-nameless }}

grammar

tvar, v :: 'la_tvar_' ::=
  | ~ x :: :: var
  | ^ x :: :: extvar

type, t, A, B :: 'la_type_' ::= 
  | int          ::   :: int
  | forall x . t ::   :: forall (+ bind x in t +) 
  | t1 -> t2     ::   :: arrow 
  | v            ::   :: var
  | ( t )        :: S :: paren {{ coq ([[t]]) }}
  | [ t / x ] A  :: M :: subst {{ coq (open_type_wrt_type [[x A]] [[t]]) }}

bounds, bs :: 'la_bounds_' ::= 
  | bnil   :: :: nil  
  | bs , t :: :: cons 

work, w :: 'la_w_' ::=
  | ~ x              :: :: tvar 
  | bs <= ^ x <= bs' :: :: extvar
  | t1 <: t2         :: :: subtyp

worklist, wl :: 'la_wl_' ::= 
  | wnil       ::   :: nil 
  | wl , w     ::   :: cons
  % | wl1 ++ wl2 :: M :: app

formula :: formula_ ::=
  | judgement  ::   :: judgement

% subrules 
%   var <:: type

freevars
  type    x :: fv

substitutions
  single type x :: subst  


embed {{ coq

Fixpoint var_dom (wl : worklist) : atoms :=
  match wl with
  | la_wl_nil => {}
  | la_wl_cons wl' (la_w_tvar tvar) => add tvar (var_dom wl')
  | la_wl_cons wl' _ => var_dom wl'
  end
.

Fixpoint extvar_dom (wl : worklist) : atoms :=
  match wl with
  | la_wl_nil => {}
  | la_wl_cons wl' (la_w_extvar bs extvar bs') => add extvar (extvar_dom wl')
  | la_wl_cons wl' _ => extvar_dom wl'
  end
.

(* Fixpoint single_side_constraints (bs : bounds ) : worklist := 
  match bounds with
  | nil => wnil
  | b, bs' => map (fun b' => la_w_subtyp b b') bs'
  end
.

Fixpoint double_side_constraints (lbs ubs : bounds) : worklist := 
  match lbs with
  | nil => wnil
  | lb, lbs' => map (fun ub => la_w_subtyp lb ub) ubs ++ double_side_constraints lbs
  end
. *)

}}


defns
Monotype :: '' ::=

defn
mono t :: :: mono_type :: 'la_mono_'
by

----------- :: texvar
mono  v

------------- :: int
mono int

mono t1
mono t2
----------------- :: arrow
mono (t1 -> t2)


defns
InWorklist :: '' ::=

defn
v in wl :: :: in_wl :: 'iwl_'
by


------------------------------ :: here_var
~ x in wl , ~ x

~ x in wl
------------------------------ :: there_var
~ x in wl , w

------------------------------ :: here_extvar
^ x in wl , bs <= ^ x <= bs'

------------------------------ :: there_extvar
^ x in wl , w


defns
InScope :: '' ::=

defn
wl [ v1 ] [ v2 ] :: :: in_scope :: 'la_ins_'
by

v1 in wl
---------------- :: here_var
wl , x [v1][x]

v1 in wl
---------------- :: here_extvar
wl , bs <= ^ x <= bs' [v1][^ x]

wl [v1][v2]
---------------- :: there_w
wl , w [v1][v2]



defns 
AlgorithmeticSubtyping :: '' ::=

defn 
|- wl :: :: wl_reduction :: 'la_wl_red'
by

|- wl
--------------------------- :: var
|- wl , ~ x

|- wl
----------------------------------------------------------- :: extvar_unfold_lnil
|- wl , bnil <= ^ x <= bs'


|- wl 
----------------------------------------------------------- :: extvar_unfold_unil
|- wl, bs <= ^ x <= bnil


|- wl
----------------------------------------------------------- :: extvar_unfold
|- wl , bs <= ^ x <= bs'

|- wl
-------------------------------------------- :: sub_int
|- wl , int <: int

|- wl
-------------------------------------------- :: sub_tvar
|- wl, ~ x <: ~ x

|- wl
-------------------------------------------- :: sub_extvar
|-  wl , ^ x <: ^ x

% ^ y # wl
|- wl , bnil <= ^ y <= bnil , [ ^ y / x] A <: B
-------------------------------------------- :: sub_forallL
|- wl , forall x. A <: B

|- wl, ~ x, A <: B
-------------------------------------------- :: sub_forallR
|- wl , A <: forall x. B


|- wl , A2 <: B2 , B1 <: A1
--------------------------- :: sub_arrow
|- wl , A1 -> A2 <: B1 -> B2

|- wl
wl [v1] [v2]
-------------------------------------------- :: sub_extvar
|- wl , v1 <: v2

