
metavar x, y, z ::= {{ repr-locally-nameless }}
metavar ex, ey, ez ::= {{ coq var }}
metavar tx, ty, tz ::= {{ coq var }}


grammar

type, t, A, B :: 'la_t_' ::= 
  | int           ::   :: int
  | forall x . t  ::   :: forall (+ bind x in t +) 
  | t1 -> t2      ::   :: arrow 
  | x             ::   :: var
  | tx            ::   :: tvar
  | ex            ::   :: evar
  | ( t )         :: S :: paren {{ coq ([[t]]) }}
  | [ t / x ] A   :: M :: susbt {{ coq (open_type_wrt_type [[x A]] [[t]]) }}

typelist, tl :: 'tl_' ::= 
  | tnil   :: :: nil  
  | tl , t :: :: cons 

work, w :: 'w_' ::=
  | tx                :: :: tvar 
  | tl <= ex <= tl'   :: :: evar
  | t1 <: t2          :: :: subtyp

worklist, wl :: 'wl_' ::= 
  | wnil                ::   :: nil 
  | wl , w              ::   :: cons
  | wl1 ++ wl2          :: M :: app {{ coq (wl_app [[wl1]] [[wl2]]) }}
  | < tl >              :: M :: single_constraint {{ coq (single_side_constraints [[tl]]) }}
  | < tl1 * tl2 >       :: M :: double_constraint {{ coq (double_side_constraints [[tl1]] [[tl2]])}}
  | wl @ ex +> t        :: M :: update_lb {{ coq (update_lowerbound_in_wl [[t]] [[wl]] [[ex]]) }}
  | wl @ ex <+ t        :: M :: update_ub {{ coq (update_upperbound_in_wl [[t]] [[wl]] [[ex]]) }}
  | wl @ ex << ex1      :: M :: add_before {{ coq (add_evar_before [[ex1]] [[wl]] [[ex]])}}


formula :: formula_ ::=
  | judgement                  ::   :: judgement
  | ex # wl                    :: M :: evar_fresh {{ coq ([[ex]] `notin` (evar_dom [[wl]])) }}
  | tx # wl                    :: M :: tvar_fresh {{ coq ([[tx]] `notin` (tvar_dom [[wl]])) }}
  | ex $ wl                    :: M :: evar_in {{ coq ([[ex]] `in` (evar_dom [[wl]])) }}
  | tx $ wl                    :: M :: tvar_in {{ coq ([[tx]] `in` (tvar_dom [[wl]])) }}
  | wl' := wl <<= ex <:> t     :: M :: reorder {{ coq (reorder [[wl]] [[ex]] [[t]] wl_nil [[wl']])}}


substitutions
  single type x :: subst


freevars
  type    x :: fv
  type    tx :: ftx
  type    ex :: fex


embed {{ coq

Fixpoint wl_app (wl1 wl2 : worklist) : worklist :=
  match wl2 with
  | wl_nil => wl1 
  | wl_cons wl2' w2 => wl_cons (wl_app wl1 wl2') w2
  end
.

Fixpoint tvar_dom (wl : worklist) : atoms :=
  match wl with
  | wl_nil => {}
  | wl_cons wl' (w_tvar tvar) => add tvar (tvar_dom wl')
  | wl_cons wl' _ => tvar_dom wl'
  end
.

Fixpoint evar_dom (wl : worklist) : atoms :=
  match wl with
  | wl_nil => {}
  | wl_cons wl' (w_evar _ evar _) => add evar (evar_dom wl')
  | wl_cons wl' _ => evar_dom wl'
  end
.

Fixpoint update_lowerbound_in_wl (t: type) (wl : worklist) (target : var) : worklist :=
  match wl with 
  | wl_nil => wl_nil
  | wl_cons wl' (w_evar tl evar tl') => 
    if (eq_dec target evar) 
      then wl_cons (update_lowerbound_in_wl t wl' target) (w_evar (tl_cons tl t) evar tl') 
      else wl_cons (update_lowerbound_in_wl t wl' target) (w_evar tl evar tl')
  | wl_cons wl' w => wl_cons (update_lowerbound_in_wl t wl' target) w
  end
.

Fixpoint update_upperbound_in_wl (t: type) (wl : worklist) (target : var) : worklist :=
  match wl with 
  | wl_nil => wl_nil
  | wl_cons wl' (w_evar tl evar tl') => 
    if (eq_dec target evar) 
      then wl_cons (update_upperbound_in_wl t wl' target) (w_evar tl evar (tl_cons tl' t)) 
      else wl_cons (update_upperbound_in_wl t wl' target) (w_evar tl evar tl')
  | wl_cons wl' w => wl_cons (update_upperbound_in_wl t wl' target) w
  end
.

Fixpoint add_evar_before (v : var) (wl : worklist) (target : var) : worklist :=
  match wl with 
  | wl_nil => wl_nil
  | wl_cons wl' (w_evar tl evar tl') => 
    if (eq_dec target v) 
      then wl_cons (wl_cons (add_evar_before v wl' target) (w_evar tl_nil v tl_nil)) (w_evar tl evar tl') 
      else wl_cons (add_evar_before v wl' target) (w_evar tl evar tl')
  | wl_cons wl' w => wl_cons (add_evar_before v wl' target) w
  end
.

Fixpoint single_side_constraints_helper (t : type) (tl : typelist) : worklist := 
  match tl with
  | tl_nil => wl_nil
  | tl_cons tl' t' => wl_cons (single_side_constraints_helper t' tl') (w_subtyp t t')
  end
.

Definition single_side_constraints (tl : typelist) : worklist := 
  match tl with
  | tl_nil => wl_nil
  | tl_cons tl' t => single_side_constraints_helper t tl'
  end
.

Fixpoint double_side_constraints_helper (t : type) (tl : typelist) : worklist :=
  match tl with 
  | tl_nil => wl_nil
  | tl_cons tl' t' => wl_cons (double_side_constraints_helper t tl') (w_subtyp t t')
  end
.

Fixpoint double_side_constraints (tl1 tl2 : typelist) : worklist :=
  match tl1 with 
  | tl_nil => wl_nil
  | tl_cons tl1' t1 => wl_app (double_side_constraints tl1' tl2) (double_side_constraints_helper t1 tl2)
  end
.

Fixpoint wl_app_rev (wl1 wl2 : worklist) : worklist :=
  match wl2 with
  | wl_nil => wl1 
  | wl_cons wl2' w2 => wl_app_rev (wl_cons wl1 w2) wl2'
  end
.

Inductive reorder : worklist -> var -> type -> worklist -> worklist -> Prop :=
| re_stop : forall Γ x lbs ubs t Γ'
  , x `notin` fex_worklist Γ' `union` fex_type t
  -> reorder (wl_cons Γ (w_evar lbs x ubs)) x t wl_nil 
  (wl_app_rev (wl_cons Γ (w_evar lbs x ubs)) Γ')
| re_tx_stay : forall Γ1 Γ2 x y t Γ'
  , y `notin` ftx_worklist Γ' `union` ftx_type t
  -> reorder Γ1 x t Γ' Γ2
  -> reorder (wl_cons Γ1 (w_tvar y)) x t Γ' (wl_cons Γ2 (w_tvar y))
| re_ex_stay : forall Γ1 Γ2 y lbs ubs x t Γ'
  , y `notin` fex_worklist Γ' `union` fex_type t
  -> reorder Γ1 x t Γ' Γ2
  -> reorder (wl_cons Γ1 (w_evar lbs y ubs)) x t Γ' (wl_cons Γ2 (w_evar lbs y ubs))
| re_ex_move : forall Γ1 Γ2 y lbs ubs x t Γ'
  , x `notin` fex_typelist lbs `union` fex_typelist ubs
  -> reorder Γ1 x t (wl_cons Γ' (w_evar lbs y ubs)) Γ2
  -> reorder (wl_cons Γ1 (w_evar lbs y ubs)) x t Γ' (wl_cons Γ2 (w_evar lbs y ubs))
| re_sub_stay : forall Γ1 Γ2 t1 t2 x t Γ' y
  , y `in` fex_worklist Γ' `union` fex_type t -> y `notin` fex_type t1 `union` fex_type t2
  -> forall y, y `in` ftx_worklist Γ' `union` ftx_type t -> y `notin` ftx_type t1 `union` ftx_type t2
  -> reorder Γ1 x t Γ' Γ2
  -> reorder (wl_cons Γ1 (w_subtyp t1 t2)) x t Γ' (wl_cons Γ2 (w_subtyp t1 t2))
| re_sub_move : forall Γ1 Γ2 t1 t2 x t Γ'
  , (exists y, 
      ((y `in` fex_worklist Γ' `union` fex_type t) /\ (y `in` fex_type t1 `union` fex_type t2)) \/ 
      ((y `in` ftx_worklist Γ' `union` ftx_type t) /\ (y `in` ftx_type t1 `union` ftx_type t2)))
  -> reorder Γ1 x t (wl_cons Γ' (w_subtyp t1 t2)) Γ2
  -> reorder (wl_cons Γ1 (w_subtyp t1 t2)) x t Γ' (wl_cons Γ2 (w_subtyp t1 t2))
.

}}


defns
Monotype :: '' ::=

defn
mono t :: :: la_mono :: 'mono_'
by

----------- :: tvar
mono tx

----------- :: evar
mono ex

------------- :: int
mono int

mono t1
mono t2
----------------- :: arrow
mono (t1 -> t2)


defns
InWorklist :: '' ::=

defn
t in wl :: :: in_wl :: 'inwl_'
by

------------------------------ :: here_tvar
tx in wl , tx

tx in wl
------------------------------ :: there_tvar
tx in wl , w

------------------------------ :: here_evar
ex in wl , tl <= ex <= tl'

------------------------------ :: there_evar
ex in wl , w


defns
InScope :: '' ::=

defn
wl [ t1 ] [ t2 ] :: :: in_scope :: 'ins_'
by

t1 in wl
------------------------------------ :: here_var
wl , tx [t1] [tx]

t1 in wl
------------------------------------ :: here_evar
wl , tl <= ex <= tl' [ t1 ] [ ex ]

wl [ t1 ] [ t2 ]
------------------------------------ :: there_w
wl , w [ t1 ] [ t2 ]



defns 
AlgorithmeticSubtyping :: '' ::=

defn 
|- wl :: :: wl_reducible :: 'wlred_'
by

|- wl
------------------------------------------------------------------ :: tvar
|- wl , tx

|- wl ++ < tl >
------------------------------------------------------------------ :: evar_nil_l
|- wl , tnil <= ex <= tl

|- wl ++ < tl' >
------------------------------------------------------------------ :: evar_nil_r
|- wl , tl <= ex <= tnil

|- wl ++ < tl * tl' >
------------------------------------------------------------------ :: evar
|- wl , tl <= ex <= tl'

|- wl
------------------------------------------------------------------ :: int_int
|- wl , int <: int

tx $ wl
|- wl
------------------------------------------------------------------ :: tvar_tvar
|- wl , tx <: tx

ex $ wl
|- wl
------------------------------------------------------------------ :: evar_evar
|- wl , ex <: ex

tx # wl
|- wl , tnil <= ex <= tnil , [ tx / x ] A <: B
------------------------------------------------------------------ :: forall_l
|- wl , forall x. A <: B

tx # wl 
|- wl , tx , [ tx / x ] A <: B
------------------------------------------------------------------ :: forall_r
|- wl , A <: forall x. B

|- wl , A2 <: B2 , B1 <: A1
------------------------------------------------------------------ :: arrow_arrow
|- wl , A1 -> A2 <: B1 -> B2

mono (A -> B)
ex $ wl
wl' := wl <<= ex <:> t 
|- wl' @ ex <+ A -> B
------------------------------------------------------------------ :: evar_arrow_mono
|- wl , ex <: A -> B

mono (A -> B)
ex $ wl
wl' := wl <<= ex <:> t 
|- wl' @ ex +> A -> B
------------------------------------------------------------------ :: arrow_evar_mono
|- wl , A -> B <: ex

ex $ wl
ex1 # wl 
ex2 # wl , tnil <= ex1 <= tnil
|- wl @ ex << ex1 @ ex << ex2 @ ex <+ (ex1 -> ex2)
------------------------------------------------------------------ :: evar_arrow
|- wl , ex <: A -> B

tx $ wl
tx1 # wl 
tx2 # wl , tnil <= ex1 <= tnil
|- wl @ ex << ex1 @ ex << ex2 @ ex +> (ex1 -> ex2)
------------------------------------------------------------------ :: arrow_evar
|- wl , A -> B <: ex

ex $ wl
|- wl @ ex +> int
------------------------------------------------------------------ :: int_evar
|- wl , int <: ex

ex $ wl
|- wl @ ex <+ int
------------------------------------------------------------------ :: evar_int
|- wl , ex <: int

wl [ tx ] [ ex ]
|- wl @ ex +> tx
------------------------------------------------------------------ :: tvar_evar
|- wl , tx <: ex

wl [ tx ] [ ex ]
|- wl @ ex <+ tx
------------------------------------------------------------------ :: evar_tvar
|- wl , ex <: tx

wl [ex] [ey]
|- wl @ ey +> ex
------------------------------------------------------------------ :: evar_evar_r
|- wl , ex <: ey

wl [ex] [ey]
|- wl @ ey <+ ex
------------------------------------------------------------------ :: evar_evar_l
|- wl , ey <: ex