
metavar x, y, z ::= {{ repr-locally-nameless }}
metavar ex, ey, ez ::= {{ coq var }}
metavar tx, ty, tz ::= {{ coq var }}


grammar

type, t, A, B :: 'la_type_' ::= 
  | int           ::   :: int
  | forall x . t  ::   :: forall (+ bind x in t +) 
  | t1 -> t2      ::   :: arrow 
  | x             ::   :: var
  | tx            ::   :: tvar
  | ex            ::   :: evar
  | ( t )         :: S :: paren {{ coq ([[t]]) }}
  | [ t / x ] A   :: M :: susbt {{ coq (open_type_wrt_type [[x A]] [[t]]) }}

typelist, tl :: 'tl_' ::= 
  | tnil   :: :: nil  
  | tl , t :: :: cons 

work, w :: 'w_' ::=
  | tx                :: :: tvar 
  | tl <= ex <= tl'   :: :: evar
  | t1 <: t2          :: :: subtyp

worklist, wl :: 'wl_' ::= 
  | wnil                ::   :: nil 
  | wl , w              ::   :: cons
  | wl1 ++ wl2          :: M :: app {{ coq (wl_app [[wl1]] [[wl2]]) }}
  | < tl >              :: M :: single_constraint {{ coq (single_side_constraints [[tl]]) }}
  | < tl1 * tl2 >       :: M :: double_constraint {{ coq (double_side_constraints [[tl1]] [[tl2]])}}
  | wl @ ex +> t      :: M :: update_lb {{ coq (update_lowerbound_in_wl [[t]] [[wl]] [[ex]]) }}
  | wl @ ex <+ t      :: M :: update_ub {{ coq (update_upperbound_in_wl [[t]] [[wl]] [[ex]]) }}
  | wl @ ex << ex1    :: M :: add_before {{ coq (add_var_before [[ex1]] [[wl]] [[ex]])}}


formula :: formula_ ::=
  | judgement                  ::   :: judgement
  | ex # wl                    :: M :: evar_fresh {{ coq ([[ex]] `notin` (evar_dom [[wl]])) }}
  | tx # wl                    :: M :: tvar_fresh {{ coq ([[tx]] `notin` (tvar_dom [[wl]])) }}
  | ex $ wl                    :: M :: evar_in {{ coq ([[ex]] `in` (evar_dom [[wl]])) }}
  | tx $ wl                    :: M :: tvar_in {{ coq ([[tx]] `in` (tvar_dom [[wl]])) }}
  | wl' := wl <<= ex <:> t     :: M :: reorder {{ coq ([[ex]] `in` (evar_dom [[wl']]))}}


substitutions
  single type x :: subst


freevars
  type    x :: fv
  type    tx :: ftx
  type    ex :: fex


embed {{ coq

Fixpoint wl_app (wl1 wl2 : worklist) : worklist :=
  match wl2 with
  | wl_nil => wl1 
  | wl_cons wl2' w2 => wl_cons (wl_app wl1 wl2') w2
  end
.

Fixpoint tvar_dom (wl : worklist) : atoms :=
  match wl with
  | wl_nil => {}
  | wl_cons wl' (w_tvar tvar) => add tvar (tvar_dom wl')
  | wl_cons wl' _ => tvar_dom wl'
  end
.

Fixpoint evar_dom (wl : worklist) : atoms :=
  match wl with
  | wl_nil => {}
  | wl_cons wl' (w_evar _ evar _) => add evar (evar_dom wl')
  | wl_cons wl' _ => evar_dom wl'
  end
.

Fixpoint update_lowerbound_in_wl (t: type) (wl : worklist) (target : var) : worklist :=
  match wl with 
  | wl_nil => wl_nil
  | wl_cons wl' (w_evar tl evar tl') => 
    if (eq_dec target evar) 
      then wl_cons (update_lowerbound_in_wl t wl' target) (w_evar (tl_cons tl t) evar tl') 
      else wl_cons (update_lowerbound_in_wl t wl' target) (w_evar tl evar tl')
  | wl_cons wl' w => wl_cons (update_lowerbound_in_wl t wl' target) w
  end
.

Fixpoint update_upperbound_in_wl (t: type) (wl : worklist) (target : var) : worklist :=
  match wl with 
  | wl_nil => wl_nil
  | wl_cons wl' (w_evar tl evar tl') => 
    if (eq_dec target evar) 
      then wl_cons (update_upperbound_in_wl t wl' target) (w_evar tl evar (tl_cons tl' t)) 
      else wl_cons (update_upperbound_in_wl t wl' target) (w_evar tl evar tl')
  | wl_cons wl' w => wl_cons (update_upperbound_in_wl t wl' target) w
  end
.

Fixpoint add_var_before (v : var) (wl : worklist) (target : var) : worklist :=
  match wl with 
  | wl_nil => wl_nil
  | wl_cons wl' (w_evar tl evar tl') => 
    if (eq_dec target v) 
      then wl_cons (wl_cons (add_var_before v wl' target) (w_evar tl_nil v tl_nil)) (w_evar tl evar tl') 
      else wl_cons (add_var_before v wl' target) (w_evar tl evar tl')
  | wl_cons wl' w => wl_cons (add_var_before v wl' target) w
  end
.

Fixpoint single_side_constraints_helper (t : type) (tl : typelist) : worklist := 
  match tl with
  | tl_nil => wl_nil
  | tl_cons tl' t' => wl_cons (single_side_constraints_helper t' tl') (w_subtyp t t')
  end
.

Definition single_side_constraints (tl : typelist) : worklist := 
  match tl with
  | tl_nil => wl_nil
  | tl_cons tl' t => single_side_constraints_helper t tl'
  end
.

Fixpoint double_side_constraints_helper (t : type) (tl : typelist) : worklist :=
  match tl with 
  | tl_nil => wl_nil
  | tl_cons tl' t' => wl_cons (double_side_constraints_helper t tl') (w_subtyp t t')
  end
.

Fixpoint double_side_constraints (tl1 tl2 : typelist) : worklist :=
  match tl1 with 
  | tl_nil => wl_nil
  | tl_cons tl1' t1 => wl_app (double_side_constraints tl1' tl2) (double_side_constraints_helper t1 tl2)
  end
.

Fixpoint wl_app_rev (wl1 wl2 : worklist) : worklist :=
  match wl2 with
  | wl_nil => wl1 
  | wl_cons wl2' w2 => wl_app_rev (wl_cons wl1 w2) wl2'
  end
.

(* Inductive reorder : worklist -> var -> type -> worklist -> worklist -> Prop :=
| re_stop : forall Γ ψ x A e
  , x `notin` fex_aexpr e
  → Γ ,′ ^x :′ A ‖ ψ ⊢ ^x ≔ e ⊣ Γ ⫢′ to_wl ψ ,′ ^x :′ A
| re_x_stay : forall Γ x A ψ y e Γ'
  , y `notin` fv_psi ψ `union` fv_aexpr e
  → Γ ‖ ψ ⊢ ^x ≔ e ⊣ Γ'
  → Γ ,′ y :′ A ‖ ψ ⊢ ^x ≔ e ⊣ Γ' ,′ y :′ A
| re_ex_move : forall Γ x A ψ y e Γ'
  , y `in` fex_psi ψ `union` fex_aexpr e
  → Γ ‖ ^y :′ A :: ψ ⊢ ^x ≔ e ⊣ Γ'
  → Γ ,′ ^y :′ A ‖ ψ ⊢ ^x ≔ e ⊣ Γ'
| re_ex_stay : forall Γ x A ψ y e Γ'
  , y `notin` fex_psi ψ `union` fex_aexpr e
  → Γ ‖ ψ ⊢ ^x ≔ e ⊣ Γ'
  → Γ ,′ ^y :′ A ‖ ψ ⊢ ^x ≔ e ⊣ Γ' ,′ ^y :′ A
| re_sub_move : forall Γ k ψ x e Γ'
  , k `in` fkv_psi ψ `union` fkv_aexpr e
  → Γ ‖ ⧼^k⧽ :: ψ ⊢ ^x ≔ e ⊣ Γ'
  → Γ ,′ ⧼^k⧽ ‖ ψ ⊢ ^x ≔ e ⊣ Γ'
| re_sub_stay : forall Γ k ψ x e Γ'
  , k `notin` fkv_psi ψ `union` fkv_aexpr e
  → Γ ‖ ψ ⊢ ^x ≔ e ⊣ Γ'
  → Γ ,′ ⧼^k⧽ ‖ ψ ⊢ ^x ≔ e ⊣ Γ' ,′ ⧼^k⧽
. *)


}}


defns
Monotype :: '' ::=

defn
mono t :: :: la_mono :: 'mono_'
by

----------- :: tvar
mono tx

----------- :: evar
mono ex

------------- :: int
mono int

mono t1
mono t2
----------------- :: arrow
mono (t1 -> t2)


defns
InWorklist :: '' ::=

defn
t in wl :: :: in_wl :: 'inwl_'
by

------------------------------ :: here_tvar
tx in wl , tx

tx in wl
------------------------------ :: there_tvar
tx in wl , w

------------------------------ :: here_evar
ex in wl , tl <= ex <= tl'

------------------------------ :: there_evar
ex in wl , w


defns
InScope :: '' ::=

defn
wl [ t1 ] [ t2 ] :: :: in_scope :: 'ins_'
by

t1 in wl
------------------------------------ :: here_var
wl , tx [t1] [tx]

t1 in wl
------------------------------------ :: here_evar
wl , tl <= ex <= tl' [ t1 ] [ ex ]

wl [ t1 ] [ t2 ]
------------------------------------ :: there_w
wl , w [ t1 ] [ t2 ]



defns 
AlgorithmeticSubtyping :: '' ::=

defn 
|- wl :: :: wl_reducible :: 'wlred_'
by

|- wl
------------------------------------------------------------------ :: var
|- wl , tx

|- wl ++ < tl >
------------------------------------------------------------------ :: unfold_lnil
|- wl , tnil <= ex <= tl

|- wl ++ < tl' >
------------------------------------------------------------------ :: unfold_unil
|- wl , tl <= ex <= tnil

|- wl ++ < tl * tl' >
------------------------------------------------------------------ :: unfold
|- wl , tl <= ex <= tl'

|- wl
------------------------------------------------------------------ :: int
|- wl , int <: int

tx $ wl
|- wl
------------------------------------------------------------------ :: tvar
|- wl , tx <: tx

ex $ wl
|- wl
------------------------------------------------------------------ :: evar
|- wl , ex <: ex

tx # wl
|- wl , tnil <= ex <= tnil , [ tx / x ] A <: B
------------------------------------------------------------------ :: forallL
|- wl , forall x. A <: B

tx # wl 
|- wl , tx , [ tx / x ] A <: B
------------------------------------------------------------------ :: forallR
|- wl , A <: forall x. B

|- wl , A2 <: B2 , B1 <: A1
------------------------------------------------------------------ :: arrow_arrow
|- wl , A1 -> A2 <: B1 -> B2

mono (A -> B)
ex $ wl
|- wl
------------------------------------------------------------------ :: evar_arrow_mono
|- wl , tx <: A -> B

mono (A -> B)
ex $ wl
wl' := wl <<= ex <:> t 
|- wl' 
------------------------------------------------------------------ :: arrow_evar_mono
|- wl , A -> B <: tx

ex $ wl
ex1 # wl 
ex2 # wl , tnil <= ex1 <= tnil
|- wl @ ex << ex1 @ ex << ex2 @ ex <+ (ex1 -> ex2)
------------------------------------------------------------------ :: evar_arrow
|- wl , ex <: A -> B

tx $ wl
tx1 # wl 
tx2 # wl , tnil <= ex1 <= tnil
|- wl @ ex << ex1 @ ex << ex2 @ ex +> (ex1 -> ex2)
------------------------------------------------------------------ :: arrow_evar
|- wl , A -> B <: ex

ex $ wl
|- wl @ ex +> int
------------------------------------------------------------------ :: int_evar
|- wl , int <: ex

ex $ wl
|- wl @ ex <+ int
------------------------------------------------------------------ :: evar_int
|- wl , ex <: int

wl [ tx ] [ty]
|- wl @ ey +>  tx
------------------------------------------------------------------ :: tvar_evar
|- wl , tx <: ty

wl [ tx ] [ty]
|- wl @ ey <+ tx
------------------------------------------------------------------ :: evar_tvar
|- wl , ey <: tx

wl [ex] [ty]
|- wl @ ey +> ex
------------------------------------------------------------------ :: evar_evarR
|- wl , ex <: ty

wl [ex] [ty]
|- wl @ ey <+ ex
------------------------------------------------------------------ :: evar_evarL
|- wl , ey <: ex