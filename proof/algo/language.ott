
metavar x, y, z ::= {{ repr-locally-nameless }}
metavar ex, ey, ez ::= {{ coq var }}


grammar

la_type, t, A, B :: 'la_t_' ::= 
  | int           ::   :: int
  | forall x . t  ::   :: forall (+ bind x in t +) 
  | t1 -> t2      ::   :: arrow 
  | x             ::   :: tvar
  | ex            ::   :: evar
  | ( t )         :: S :: paren {{ coq ([[t]]) }}
  | [ t / x ] A   :: M :: subst {{ coq (open_la_type_wrt_la_type [[x A]] [[t]]) }}

la_typelist, tl :: 'la_tl_' ::= 
  | tnil    :: :: nil  
  | tl , t  :: :: cons 


la_work, w :: 'la_w_' ::=
  | t1 <: t2         :: :: sub

la_mode, m :: 'la_m_' ::=
  | +                :: :: u
  | -                :: :: l

la_worklist, wl :: 'la_wl_' ::= 
  | wnil               ::   :: nil 
  | wl , x             ::   :: cons_tv
  | wl , tl ≤ ex ≤ tl' ::   :: cons_ev
  | wl |- w            ::   :: cons_w
  | wl1 ++ wl2         :: M :: app {{ coq (la_wl_app [[wl1]] [[wl2]]) }}
  | < tl >             :: M :: single_constraint {{ coq (single_side_constraints [[tl]]) }}
  | < tl1 * tl2 >      :: M :: double_constraint {{ coq (double_side_constraints [[tl1]] [[tl2]])}}


formula :: formula_ ::=
  | judgement               ::   :: judgement
  | ex notin wl             :: M :: evar_fresh {{ coq ([[ex]] `notin` (evar_dom [[wl]])) }}
  | x notin wl              :: M :: tvar_fresh {{ coq ([[x]] `notin` (tvar_dom [[wl]])) }}
  | m { ex ∪ t } wl -> wl'  :: M :: reorder {{ coq (reorder [[wl]] [[ex]] [[t]] [[m]] la_wl_nil [[wl']]) }}
  | tl != ∅                 :: M :: tl_ne {{ coq (la_tl_not_empty [[tl]] )}}

substitutions
  single la_type x :: subst
  single la_type ex :: ex_subst

freevars
  la_type  x   :: fx
  la_type  ex  :: fex


embed {{ coq

Fixpoint la_wl_app (wl1 wl2 : la_worklist) : la_worklist :=
  match wl2 with
  | la_wl_nil => wl1 
  | la_wl_cons_tv wl2' x2 => la_wl_cons_tv (la_wl_app wl1 wl2') x2
  | la_wl_cons_ev wl2' lbs2 ex2 ubs2 => la_wl_cons_ev (la_wl_app wl1 wl2') lbs2 ex2 ubs2
  | la_wl_cons_w wl2' w2 => la_wl_cons_w (la_wl_app wl1 wl2') w2
  end
.

Fixpoint tvar_dom (wl : la_worklist) : atoms :=
  match wl with
  | la_wl_nil => {}
  | la_wl_cons_tv wl' x => add x (tvar_dom wl')
  | la_wl_cons_ev wl' _ _ _ => tvar_dom wl'
  | la_wl_cons_w wl' _ => tvar_dom wl'
  end
.

Fixpoint evar_dom (wl : la_worklist) : atoms :=
  match wl with
  | la_wl_nil => {}
  | la_wl_cons_ev wl' _ ex _ => add ex (evar_dom wl')
  | la_wl_cons_w wl' _ => evar_dom wl'
  | la_wl_cons_tv wl' _ => evar_dom wl'
  end
.

Fixpoint single_side_constraints_helper (t : la_type) (tl : la_typelist) : la_worklist := 
  match tl with
  | la_tl_nil => la_wl_nil
  | la_tl_cons tl' t' => la_wl_cons_w (single_side_constraints_helper t tl') (la_w_sub t t')
  end
.

Definition single_side_constraints (tl : la_typelist) : la_worklist := 
  match tl with
  | la_tl_nil => la_wl_nil
  | la_tl_cons tl' t => single_side_constraints_helper t tl'
  end
.

Fixpoint double_side_constraints_helper (t : la_type) (tl : la_typelist) : la_worklist :=
  match tl with 
  | la_tl_nil => la_wl_nil
  | la_tl_cons tl' t' => la_wl_cons_w (double_side_constraints_helper t tl') (la_w_sub t t')
  end
.

Fixpoint double_side_constraints (tl1 tl2 : la_typelist) : la_worklist :=
  match tl1 with 
  | la_tl_nil => la_wl_nil
  | la_tl_cons tl1' t1 => la_wl_app (double_side_constraints tl1' tl2) (double_side_constraints_helper t1 tl2)
  end
.

Fixpoint la_wl_app_rev (wl1 wl2 : la_worklist) : la_worklist :=
  match wl2 with
  | la_wl_nil => wl1 
  | la_wl_cons_ev wl2' lbs2 ex2 ubs2 => la_wl_app_rev (la_wl_cons_ev wl1 lbs2 ex2 ubs2) wl2'
  | la_wl_cons_w wl2' w2 => la_wl_app_rev (la_wl_cons_w wl1 w2) wl2'
  | la_wl_cons_tv wl2' x2 => la_wl_app_rev (la_wl_cons_tv wl1 x2) wl2'
  end
.

Inductive reorder : la_worklist -> var -> la_type -> la_mode -> la_worklist -> la_worklist -> Prop :=
  | re_add_ub : forall Γ x lbs ubs t Γ'
    , x `notin` fex_la_worklist Γ' `union` fex_la_type t
    -> reorder (la_wl_cons_ev Γ lbs x ubs) x t la_m_u la_wl_nil 
    (la_wl_app_rev (la_wl_cons_ev Γ lbs x (la_tl_cons ubs t)) Γ')
  | re_add_lb : forall Γ x lbs ubs t Γ'
    , x `notin` fex_la_worklist Γ' `union` fex_la_type t
    -> reorder (la_wl_cons_ev Γ lbs x ubs) x t la_m_l la_wl_nil 
    (la_wl_app_rev (la_wl_cons_ev Γ (la_tl_cons lbs t) x ubs) Γ')
  | re_x_stay : forall Γ1 Γ2 x y t m Γ'
    , y `notin` fx_la_worklist Γ' `union` fx_la_type t
    -> reorder Γ1 x t m Γ' Γ2
    -> reorder (la_wl_cons_tv Γ1 y) x t m Γ' (la_wl_cons_tv Γ2 y)
  | re_ex_stay : forall Γ1 Γ2 y lbs ubs x t m Γ'
    , y `notin` fex_la_worklist Γ' `union` fex_la_type t
    -> reorder Γ1 x t m Γ' Γ2
    -> reorder (la_wl_cons_ev Γ1 lbs y ubs) x t m Γ' (la_wl_cons_ev Γ2 lbs y ubs)
  | re_ex_move : forall Γ1 Γ2 y lbs ubs x t m Γ'
    , x `notin` fex_la_typelist lbs `union` fex_la_typelist ubs
    -> reorder Γ1 x t m (la_wl_cons_ev Γ' lbs y ubs) Γ2
    -> reorder (la_wl_cons_ev Γ1 lbs y ubs) x t m Γ' (la_wl_cons_ev Γ2 lbs y ubs)
  | re_sub_stay : forall Γ1 Γ2 t1 t2 x t m Γ' 
    , reorder Γ1 x t m Γ' Γ2
    -> reorder (la_wl_cons_w Γ1 (la_w_sub t1 t2)) x t m Γ' (la_wl_cons_w Γ2 (la_w_sub t1 t2))
  .

Inductive la_tl_not_empty : la_typelist -> Prop := 
  | la_tl_ne : forall tl t, la_tl_not_empty (la_tl_cons tl t)
.

}}


defns
Monotype :: '' ::=

defn
mono t :: :: la_mono_type :: 'la_mono_'
by

----------------- :: tvar
mono x

----------------- :: evar
mono ex

----------------- :: int
mono int

mono t1
mono t2
----------------- :: arrow
mono (t1 -> t2)


defns
NotForallType :: '' ::=

defn
~∀ A :: :: la_notforall_type :: 'la_nf_'
by

--------------- :: int
~∀ int

--------------- :: var
~∀ x

--------------- :: arrow
~∀ t1 -> t2


defns
InWorklist :: '' ::=

defn
t in wl :: :: la_in_worklist :: 'la_inwl_'
by

---------------------------- :: tv_here
x in wl , x

x in wl
---------------------------  :: tv_there_tv
x in wl , y

x in wl 
--------------------------   :: tv_there_ev
x in wl , tl ≤ ex ≤ tl'

x in wl
---------------------------- :: tv_there_w
x in wl |- w

---------------------------- :: ev_here
ex in wl , tl ≤ ex ≤ tl'

ex in wl 
---------------------------- :: ev_there_tv
ex in wl , x

ex in wl 
---------------------------- :: ev_there_ev
ex in wl , tl ≤ ey ≤ tl'

ex in wl
---------------------------- :: ev_there_w
ex in wl |- w


defns
WellFormedType :: '' ::=

defn
wl |=> t  :: :: la_wf_type :: 'la_wft_'
by

---------------- :: int
wl |=>  int

ex in wl
----------------- :: evar
wl |=> ex

x in wl 
---------------- :: tvar
wl |=> x

wl |=>  t1 
wl |=>  t2 
---------------- :: arrow
wl |=>  t1 -> t2

wl , x |=> t 
----------------- :: forall 
wl |=> forall x. t


defns
WellFormedMonoType :: '' ::=

defn
wl |==> t  :: :: la_wf_mtype :: 'la_wfmt_'
by

---------------- :: int
wl |==> int

x in wl 
---------------- :: tvar
wl |==> x

ex in wl 
---------------- :: evar
wl |==> ex

wl |==> t1
wl |==> t2 
---------------- :: arrow
wl |==> t1 -> t2




defns
InScope :: '' ::=

defn
wl [ t1 ] [ t2 ] :: :: la_in_scope :: 'la_ins_'
by

ex1 in wl
------------------------------------ :: ev_here
wl , tl ≤ ex2 ≤ tl' [ex1] [ex2]


wl [ ex1 ] [ ex2 ]
------------------------------------ :: tv_between
wl , x [ ex1 ] [ ex2 ]


wl [ ex1 ] [ ex2 ]
------------------------------------ :: ev_between
wl , tl ≤ ex ≤ tl' [ ex1 ] [ ex2 ]


wl [ ex1 ] [ ex2 ]
------------------------------------ :: w_between
wl |- w [ ex1 ] [ ex2 ]


defns 
AlgorithmeticSubtyping :: '' ::=

defn 
|- wl :: :: la_worklist_reducible :: 'la_wlred_'
by

x notin wl
|- wl
---------------------------------------------------- :: tvar
|- wl , x

ex notin wl
|- wl ++ < tl >
---------------------------------------------------- :: evar_nil_l
|- wl , tnil ≤ ex ≤ tl

|- wl ++ < tl' >
---------------------------------------------------- :: evar_nil_r
|- wl , tl ≤ ex ≤ tnil

tl != ∅
tl' != ∅
|- wl ++ < tl * tl' >
---------------------------------------------------- :: evar
|- wl , tl ≤ ex ≤ tl'

|- wl
---------------------------------------------------- :: int_int
|- wl |- int <: int

x in wl
|- wl
---------------------------------------------------- :: tvar_tvar
|- wl |- x <: x

ex in wl
|- wl
---------------------------------------------------- :: evar_evar
|- wl |- ex <: ex

~∀ B
ex notin wl
|- wl , tnil ≤ ex ≤ tnil |- [ ex / x ] A <: B
---------------------------------------------------- :: forall_l
|- wl |- forall x. A <: B

|- wl , x |- A <: B
---------------------------------------------------- :: forall_r
|- wl |- A <: forall x. B

|- wl |- A2 <: B2 |- B1 <: A1
---------------------------------------------------- :: arrow_arrow
|- wl |- A1 -> A2 <: B1 -> B2

% ex in wl
% mono (A -> B)
% + { ex ∪ (A -> B) } wl -> wl'
% |- wl'
% ---------------------------------------------------- :: evar_arrow_mono
% |- wl |- ex <: A -> B

% ex in wl
% mono (A -> B)
% - { ex ∪ (A -> B) } wl -> wl'
% |- wl' 
% ---------------------------------------------------- :: arrow_evar_mono
% |- wl |- A -> B <: ex

ex in wl
ex1 notin wl 
ex2 notin wl , tnil ≤ ex1 ≤ tnil
+ { ex ∪ (ex1 -> ex2) } wl , tnil ≤ ex1 ≤ tnil , tnil ≤ ex2 ≤ tnil -> wl'
|- wl' |- ex1 -> ex2 <: A -> B
---------------------------------------------------- :: evar_arrow
|- wl |- ex <: A -> B

ex in wl
ex1 notin wl 
ex2 notin wl , tnil ≤ ex1 ≤ tnil
- { ex ∪ (ex1 -> ex2) } wl , tnil ≤ ex1 ≤ tnil , tnil ≤ ex2 ≤ tnil -> wl'
|- wl' |- A -> B <: ex1 -> ex2 
---------------------------------------------------- :: arrow_evar
|- wl |- A -> B <: ex

wl [ey] [ex]
+ { ex ∪ ey } wl -> wl'
|- wl'
---------------------------------------------------- :: evar_evar_l
|- wl |- ex <: ey

wl [ey] [ex]
- { ex ∪ ey } wl -> wl'
|- wl'
---------------------------------------------------- :: evar_evar_r
|- wl |- ey <: ex

ex in wl
mono t
- { ex ∪ t } wl -> wl'
|- wl'
---------------------------------------------------- :: mono_evar
|- wl |- t <: ex

ex in wl
mono t
+ { ex ∪ t } wl -> wl'
|- wl'
---------------------------------------------------- :: evar_mono
|- wl |- ex <: t



