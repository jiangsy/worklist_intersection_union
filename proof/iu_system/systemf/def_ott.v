(* generated by Ott 0.32, locally-nameless lngen from: systemf/language.ott *)
Require Import Bool.
Require Import Metalib.Metatheory.
Require Import List.
(** syntax *)
Definition typvar : Set := var.
Definition expvar : Set := var.

Inductive ftyp : Set := 
 | ftyp_unit : ftyp
 | ftyp_top : ftyp
 | ftyp_var_b (_:nat)
 | ftyp_var_f (X:typvar)
 | ftyp_arrow (T1:ftyp) (T2:ftyp)
 | ftyp_all (T:ftyp)
 | ftyp_sum (T1:ftyp) (T2:ftyp)
 | ftyp_prod (T1:ftyp) (T2:ftyp).

Inductive binding : Set := 
 | bind_tvar_empty : binding
 | bind_typ (T:ftyp).

Inductive fexp : Set := 
 | fexp_var_b (_:nat)
 | fexp_var_f (x:expvar)
 | fexp_abs (T:ftyp) (e:fexp)
 | fexp_app (e1:fexp) (e2:fexp)
 | fexp_tabs (e:fexp)
 | fexp_tapp (e:fexp) (T:ftyp)
 | fexp_inl (e:fexp)
 | fexp_inr (e:fexp)
 | fexp_case (e:fexp) (e2:fexp) (e3:fexp)
 | fexp_proj1 (e:fexp)
 | fexp_proj2 (e:fexp)
 | fexp_pair (e1:fexp) (e2:fexp).

Definition fenv : Set := list (atom*binding).

(* EXPERIMENTAL *)
(** auxiliary functions on the new list types *)
(** library functions *)
(** subrules *)
Fixpoint is_fvalue_of_fexp (e_5:fexp) : bool :=
  match e_5 with
  | (fexp_var_b nat) => false
  | (fexp_var_f x) => false
  | (fexp_abs T e) => (true)
  | (fexp_app e1 e2) => false
  | (fexp_tabs e) => (true)
  | (fexp_tapp e T) => false
  | (fexp_inl e) => ((is_fvalue_of_fexp e))
  | (fexp_inr e) => ((is_fvalue_of_fexp e))
  | (fexp_case e e2 e3) => false
  | (fexp_proj1 e) => false
  | (fexp_proj2 e) => false
  | (fexp_pair e1 e2) => ((is_fvalue_of_fexp e1) && (is_fvalue_of_fexp e2))
end.

(** arities *)
(** opening up abstractions *)
Fixpoint open_ftyp_wrt_ftyp_rec (k:nat) (T_5:ftyp) (T__6:ftyp) {struct T__6}: ftyp :=
  match T__6 with
  | ftyp_unit => ftyp_unit 
  | ftyp_top => ftyp_top 
  | (ftyp_var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => ftyp_var_b nat
        | inleft (right _) => T_5
        | inright _ => ftyp_var_b (nat - 1)
      end
  | (ftyp_var_f X) => ftyp_var_f X
  | (ftyp_arrow T1 T2) => ftyp_arrow (open_ftyp_wrt_ftyp_rec k T_5 T1) (open_ftyp_wrt_ftyp_rec k T_5 T2)
  | (ftyp_all T) => ftyp_all (open_ftyp_wrt_ftyp_rec (S k) T_5 T)
  | (ftyp_sum T1 T2) => ftyp_sum (open_ftyp_wrt_ftyp_rec k T_5 T1) (open_ftyp_wrt_ftyp_rec k T_5 T2)
  | (ftyp_prod T1 T2) => ftyp_prod (open_ftyp_wrt_ftyp_rec k T_5 T1) (open_ftyp_wrt_ftyp_rec k T_5 T2)
end.

Fixpoint open_fexp_wrt_fexp_rec (k:nat) (e_5:fexp) (e__6:fexp) {struct e__6}: fexp :=
  match e__6 with
  | (fexp_var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => fexp_var_b nat
        | inleft (right _) => e_5
        | inright _ => fexp_var_b (nat - 1)
      end
  | (fexp_var_f x) => fexp_var_f x
  | (fexp_abs T e) => fexp_abs T (open_fexp_wrt_fexp_rec (S k) e_5 e)
  | (fexp_app e1 e2) => fexp_app (open_fexp_wrt_fexp_rec k e_5 e1) (open_fexp_wrt_fexp_rec k e_5 e2)
  | (fexp_tabs e) => fexp_tabs (open_fexp_wrt_fexp_rec k e_5 e)
  | (fexp_tapp e T) => fexp_tapp (open_fexp_wrt_fexp_rec k e_5 e) T
  | (fexp_inl e) => fexp_inl (open_fexp_wrt_fexp_rec k e_5 e)
  | (fexp_inr e) => fexp_inr (open_fexp_wrt_fexp_rec k e_5 e)
  | (fexp_case e e2 e3) => fexp_case (open_fexp_wrt_fexp_rec k e_5 e) (open_fexp_wrt_fexp_rec (S k) e_5 e2) (open_fexp_wrt_fexp_rec (S k) e_5 e3)
  | (fexp_proj1 e) => fexp_proj1 (open_fexp_wrt_fexp_rec k e_5 e)
  | (fexp_proj2 e) => fexp_proj2 (open_fexp_wrt_fexp_rec k e_5 e)
  | (fexp_pair e1 e2) => fexp_pair (open_fexp_wrt_fexp_rec k e_5 e1) (open_fexp_wrt_fexp_rec k e_5 e2)
end.

Fixpoint open_fexp_wrt_ftyp_rec (k:nat) (T_5:ftyp) (e_5:fexp) {struct e_5}: fexp :=
  match e_5 with
  | (fexp_var_b nat) => fexp_var_b nat
  | (fexp_var_f x) => fexp_var_f x
  | (fexp_abs T e) => fexp_abs (open_ftyp_wrt_ftyp_rec k T_5 T) (open_fexp_wrt_ftyp_rec k T_5 e)
  | (fexp_app e1 e2) => fexp_app (open_fexp_wrt_ftyp_rec k T_5 e1) (open_fexp_wrt_ftyp_rec k T_5 e2)
  | (fexp_tabs e) => fexp_tabs (open_fexp_wrt_ftyp_rec (S k) T_5 e)
  | (fexp_tapp e T) => fexp_tapp (open_fexp_wrt_ftyp_rec k T_5 e) (open_ftyp_wrt_ftyp_rec k T_5 T)
  | (fexp_inl e) => fexp_inl (open_fexp_wrt_ftyp_rec k T_5 e)
  | (fexp_inr e) => fexp_inr (open_fexp_wrt_ftyp_rec k T_5 e)
  | (fexp_case e e2 e3) => fexp_case (open_fexp_wrt_ftyp_rec k T_5 e) (open_fexp_wrt_ftyp_rec k T_5 e2) (open_fexp_wrt_ftyp_rec k T_5 e3)
  | (fexp_proj1 e) => fexp_proj1 (open_fexp_wrt_ftyp_rec k T_5 e)
  | (fexp_proj2 e) => fexp_proj2 (open_fexp_wrt_ftyp_rec k T_5 e)
  | (fexp_pair e1 e2) => fexp_pair (open_fexp_wrt_ftyp_rec k T_5 e1) (open_fexp_wrt_ftyp_rec k T_5 e2)
end.

Definition open_binding_wrt_ftyp_rec (k:nat) (T5:ftyp) (b5:binding) : binding :=
  match b5 with
  | bind_tvar_empty => bind_tvar_empty 
  | (bind_typ T) => bind_typ (open_ftyp_wrt_ftyp_rec k T5 T)
end.

Definition open_fexp_wrt_fexp e_5 e__6 := open_fexp_wrt_fexp_rec 0 e__6 e_5.

Definition open_fexp_wrt_ftyp T_5 e_5 := open_fexp_wrt_ftyp_rec 0 e_5 T_5.

Definition open_ftyp_wrt_ftyp T_5 T__6 := open_ftyp_wrt_ftyp_rec 0 T__6 T_5.

Definition open_binding_wrt_ftyp T5 b5 := open_binding_wrt_ftyp_rec 0 b5 T5.

(** closing up abstractions *)
Fixpoint close_ftyp_wrt_ftyp_rec (k:nat) (T_5:var) (T__6:ftyp) {struct T__6}: ftyp :=
  match T__6 with
  | ftyp_unit => ftyp_unit 
  | ftyp_top => ftyp_top 
  | (ftyp_var_b nat) => 
       if (lt_dec nat k) 
         then ftyp_var_b nat
         else ftyp_var_b (S nat)
  | (ftyp_var_f X) => if (T_5 === X) then (ftyp_var_b k) else (ftyp_var_f X)
  | (ftyp_arrow T1 T2) => ftyp_arrow (close_ftyp_wrt_ftyp_rec k T_5 T1) (close_ftyp_wrt_ftyp_rec k T_5 T2)
  | (ftyp_all T) => ftyp_all (close_ftyp_wrt_ftyp_rec (S k) T_5 T)
  | (ftyp_sum T1 T2) => ftyp_sum (close_ftyp_wrt_ftyp_rec k T_5 T1) (close_ftyp_wrt_ftyp_rec k T_5 T2)
  | (ftyp_prod T1 T2) => ftyp_prod (close_ftyp_wrt_ftyp_rec k T_5 T1) (close_ftyp_wrt_ftyp_rec k T_5 T2)
end.

Definition close_binding_wrt_ftyp_rec (k:nat) (T5:var) (b5:binding) : binding :=
  match b5 with
  | bind_tvar_empty => bind_tvar_empty 
  | (bind_typ T) => bind_typ (close_ftyp_wrt_ftyp_rec k T5 T)
end.

Fixpoint close_fexp_wrt_fexp_rec (k:nat) (e_5:var) (e__6:fexp) {struct e__6}: fexp :=
  match e__6 with
  | (fexp_var_b nat) => 
       if (lt_dec nat k) 
         then fexp_var_b nat
         else fexp_var_b (S nat)
  | (fexp_var_f x) => if (e_5 === x) then (fexp_var_b k) else (fexp_var_f x)
  | (fexp_abs T e) => fexp_abs T (close_fexp_wrt_fexp_rec (S k) e_5 e)
  | (fexp_app e1 e2) => fexp_app (close_fexp_wrt_fexp_rec k e_5 e1) (close_fexp_wrt_fexp_rec k e_5 e2)
  | (fexp_tabs e) => fexp_tabs (close_fexp_wrt_fexp_rec k e_5 e)
  | (fexp_tapp e T) => fexp_tapp (close_fexp_wrt_fexp_rec k e_5 e) T
  | (fexp_inl e) => fexp_inl (close_fexp_wrt_fexp_rec k e_5 e)
  | (fexp_inr e) => fexp_inr (close_fexp_wrt_fexp_rec k e_5 e)
  | (fexp_case e e2 e3) => fexp_case (close_fexp_wrt_fexp_rec k e_5 e) (close_fexp_wrt_fexp_rec (S k) e_5 e2) (close_fexp_wrt_fexp_rec (S k) e_5 e3)
  | (fexp_proj1 e) => fexp_proj1 (close_fexp_wrt_fexp_rec k e_5 e)
  | (fexp_proj2 e) => fexp_proj2 (close_fexp_wrt_fexp_rec k e_5 e)
  | (fexp_pair e1 e2) => fexp_pair (close_fexp_wrt_fexp_rec k e_5 e1) (close_fexp_wrt_fexp_rec k e_5 e2)
end.

Fixpoint close_fexp_wrt_ftyp_rec (k:nat) (T_5:var) (e_5:fexp) {struct e_5}: fexp :=
  match e_5 with
  | (fexp_var_b nat) => fexp_var_b nat
  | (fexp_var_f x) => fexp_var_f x
  | (fexp_abs T e) => fexp_abs (close_ftyp_wrt_ftyp_rec k T_5 T) (close_fexp_wrt_ftyp_rec k T_5 e)
  | (fexp_app e1 e2) => fexp_app (close_fexp_wrt_ftyp_rec k T_5 e1) (close_fexp_wrt_ftyp_rec k T_5 e2)
  | (fexp_tabs e) => fexp_tabs (close_fexp_wrt_ftyp_rec (S k) T_5 e)
  | (fexp_tapp e T) => fexp_tapp (close_fexp_wrt_ftyp_rec k T_5 e) (close_ftyp_wrt_ftyp_rec k T_5 T)
  | (fexp_inl e) => fexp_inl (close_fexp_wrt_ftyp_rec k T_5 e)
  | (fexp_inr e) => fexp_inr (close_fexp_wrt_ftyp_rec k T_5 e)
  | (fexp_case e e2 e3) => fexp_case (close_fexp_wrt_ftyp_rec k T_5 e) (close_fexp_wrt_ftyp_rec k T_5 e2) (close_fexp_wrt_ftyp_rec k T_5 e3)
  | (fexp_proj1 e) => fexp_proj1 (close_fexp_wrt_ftyp_rec k T_5 e)
  | (fexp_proj2 e) => fexp_proj2 (close_fexp_wrt_ftyp_rec k T_5 e)
  | (fexp_pair e1 e2) => fexp_pair (close_fexp_wrt_ftyp_rec k T_5 e1) (close_fexp_wrt_ftyp_rec k T_5 e2)
end.

Definition close_binding_wrt_ftyp b5 T5 := close_binding_wrt_ftyp_rec 0 b5 T5.

Definition close_fexp_wrt_fexp e__6 e_5 := close_fexp_wrt_fexp_rec 0 e__6 e_5.

Definition close_fexp_wrt_ftyp e_5 T_5 := close_fexp_wrt_ftyp_rec 0 e_5 T_5.

Definition close_ftyp_wrt_ftyp T__6 T_5 := close_ftyp_wrt_ftyp_rec 0 T__6 T_5.

(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_ftyp *)
Inductive lc_ftyp : ftyp -> Prop :=    (* defn lc_ftyp *)
 | lc_ftyp_unit : 
     (lc_ftyp ftyp_unit)
 | lc_ftyp_top : 
     (lc_ftyp ftyp_top)
 | lc_ftyp_var_f : forall (X:typvar),
     (lc_ftyp (ftyp_var_f X))
 | lc_ftyp_arrow : forall (T1 T2:ftyp),
     (lc_ftyp T1) ->
     (lc_ftyp T2) ->
     (lc_ftyp (ftyp_arrow T1 T2))
 | lc_ftyp_all : forall (T:ftyp),
      ( forall X , lc_ftyp  ( open_ftyp_wrt_ftyp T (ftyp_var_f X) )  )  ->
     (lc_ftyp (ftyp_all T))
 | lc_ftyp_sum : forall (T1 T2:ftyp),
     (lc_ftyp T1) ->
     (lc_ftyp T2) ->
     (lc_ftyp (ftyp_sum T1 T2))
 | lc_ftyp_prod : forall (T1 T2:ftyp),
     (lc_ftyp T1) ->
     (lc_ftyp T2) ->
     (lc_ftyp (ftyp_prod T1 T2)).

(* defns LC_binding *)
Inductive lc_binding : binding -> Prop :=    (* defn lc_binding *)
 | lc_bind_tvar_empty : 
     (lc_binding bind_tvar_empty)
 | lc_bind_typ : forall (T:ftyp),
     (lc_ftyp T) ->
     (lc_binding (bind_typ T)).

(* defns LC_fexp *)
Inductive lc_fexp : fexp -> Prop :=    (* defn lc_fexp *)
 | lc_fexp_var_f : forall (x:expvar),
     (lc_fexp (fexp_var_f x))
 | lc_fexp_abs : forall (T:ftyp) (e:fexp),
     (lc_ftyp T) ->
      ( forall x , lc_fexp  ( open_fexp_wrt_fexp e (fexp_var_f x) )  )  ->
     (lc_fexp (fexp_abs T e))
 | lc_fexp_app : forall (e1 e2:fexp),
     (lc_fexp e1) ->
     (lc_fexp e2) ->
     (lc_fexp (fexp_app e1 e2))
 | lc_fexp_tabs : forall (e:fexp),
      ( forall X , lc_fexp  ( open_fexp_wrt_ftyp e (ftyp_var_f X) )  )  ->
     (lc_fexp (fexp_tabs e))
 | lc_fexp_tapp : forall (e:fexp) (T:ftyp),
     (lc_fexp e) ->
     (lc_ftyp T) ->
     (lc_fexp (fexp_tapp e T))
 | lc_fexp_inl : forall (e:fexp),
     (lc_fexp e) ->
     (lc_fexp (fexp_inl e))
 | lc_fexp_inr : forall (e:fexp),
     (lc_fexp e) ->
     (lc_fexp (fexp_inr e))
 | lc_fexp_case : forall (e e2 e3:fexp),
     (lc_fexp e) ->
      ( forall x , lc_fexp  ( open_fexp_wrt_fexp e2 (fexp_var_f x) )  )  ->
      ( forall y , lc_fexp  ( open_fexp_wrt_fexp e3 (fexp_var_f y) )  )  ->
     (lc_fexp (fexp_case e e2 e3))
 | lc_fexp_proj1 : forall (e:fexp),
     (lc_fexp e) ->
     (lc_fexp (fexp_proj1 e))
 | lc_fexp_proj2 : forall (e:fexp),
     (lc_fexp e) ->
     (lc_fexp (fexp_proj2 e))
 | lc_fexp_pair : forall (e1 e2:fexp),
     (lc_fexp e1) ->
     (lc_fexp e2) ->
     (lc_fexp (fexp_pair e1 e2)).
(** free variables *)
Fixpoint fv_ftyp_in_ftyp (T_5:ftyp) : vars :=
  match T_5 with
  | ftyp_unit => {}
  | ftyp_top => {}
  | (ftyp_var_b nat) => {}
  | (ftyp_var_f X) => {{X}}
  | (ftyp_arrow T1 T2) => (fv_ftyp_in_ftyp T1) \u (fv_ftyp_in_ftyp T2)
  | (ftyp_all T) => (fv_ftyp_in_ftyp T)
  | (ftyp_sum T1 T2) => (fv_ftyp_in_ftyp T1) \u (fv_ftyp_in_ftyp T2)
  | (ftyp_prod T1 T2) => (fv_ftyp_in_ftyp T1) \u (fv_ftyp_in_ftyp T2)
end.

Definition fv_ftyp_in_binding (b5:binding) : vars :=
  match b5 with
  | bind_tvar_empty => {}
  | (bind_typ T) => (fv_ftyp_in_ftyp T)
end.

Fixpoint fv_fexp_in_fexp (e_5:fexp) : vars :=
  match e_5 with
  | (fexp_var_b nat) => {}
  | (fexp_var_f x) => {{x}}
  | (fexp_abs T e) => (fv_fexp_in_fexp e)
  | (fexp_app e1 e2) => (fv_fexp_in_fexp e1) \u (fv_fexp_in_fexp e2)
  | (fexp_tabs e) => (fv_fexp_in_fexp e)
  | (fexp_tapp e T) => (fv_fexp_in_fexp e)
  | (fexp_inl e) => (fv_fexp_in_fexp e)
  | (fexp_inr e) => (fv_fexp_in_fexp e)
  | (fexp_case e e2 e3) => (fv_fexp_in_fexp e) \u (fv_fexp_in_fexp e2) \u (fv_fexp_in_fexp e3)
  | (fexp_proj1 e) => (fv_fexp_in_fexp e)
  | (fexp_proj2 e) => (fv_fexp_in_fexp e)
  | (fexp_pair e1 e2) => (fv_fexp_in_fexp e1) \u (fv_fexp_in_fexp e2)
end.

Fixpoint fv_ftyp_in_fexp (e_5:fexp) : vars :=
  match e_5 with
  | (fexp_var_b nat) => {}
  | (fexp_var_f x) => {}
  | (fexp_abs T e) => (fv_ftyp_in_ftyp T) \u (fv_ftyp_in_fexp e)
  | (fexp_app e1 e2) => (fv_ftyp_in_fexp e1) \u (fv_ftyp_in_fexp e2)
  | (fexp_tabs e) => (fv_ftyp_in_fexp e)
  | (fexp_tapp e T) => (fv_ftyp_in_fexp e) \u (fv_ftyp_in_ftyp T)
  | (fexp_inl e) => (fv_ftyp_in_fexp e)
  | (fexp_inr e) => (fv_ftyp_in_fexp e)
  | (fexp_case e e2 e3) => (fv_ftyp_in_fexp e) \u (fv_ftyp_in_fexp e2) \u (fv_ftyp_in_fexp e3)
  | (fexp_proj1 e) => (fv_ftyp_in_fexp e)
  | (fexp_proj2 e) => (fv_ftyp_in_fexp e)
  | (fexp_pair e1 e2) => (fv_ftyp_in_fexp e1) \u (fv_ftyp_in_fexp e2)
end.

(** substitutions *)
Fixpoint subst_typ_in_ftyp (T_5:ftyp) (X5:typvar) (T__6:ftyp) {struct T__6} : ftyp :=
  match T__6 with
  | ftyp_unit => ftyp_unit 
  | ftyp_top => ftyp_top 
  | (ftyp_var_b nat) => ftyp_var_b nat
  | (ftyp_var_f X) => (if eq_var X X5 then T_5 else (ftyp_var_f X))
  | (ftyp_arrow T1 T2) => ftyp_arrow (subst_typ_in_ftyp T_5 X5 T1) (subst_typ_in_ftyp T_5 X5 T2)
  | (ftyp_all T) => ftyp_all (subst_typ_in_ftyp T_5 X5 T)
  | (ftyp_sum T1 T2) => ftyp_sum (subst_typ_in_ftyp T_5 X5 T1) (subst_typ_in_ftyp T_5 X5 T2)
  | (ftyp_prod T1 T2) => ftyp_prod (subst_typ_in_ftyp T_5 X5 T1) (subst_typ_in_ftyp T_5 X5 T2)
end.

Definition subst_typ_in_binding (T5:ftyp) (X5:typvar) (b5:binding) : binding :=
  match b5 with
  | bind_tvar_empty => bind_tvar_empty 
  | (bind_typ T) => bind_typ (subst_typ_in_ftyp T5 X5 T)
end.

Fixpoint subst_exp_in_fexp (e_5:fexp) (x5:expvar) (e__6:fexp) {struct e__6} : fexp :=
  match e__6 with
  | (fexp_var_b nat) => fexp_var_b nat
  | (fexp_var_f x) => (if eq_var x x5 then e_5 else (fexp_var_f x))
  | (fexp_abs T e) => fexp_abs T (subst_exp_in_fexp e_5 x5 e)
  | (fexp_app e1 e2) => fexp_app (subst_exp_in_fexp e_5 x5 e1) (subst_exp_in_fexp e_5 x5 e2)
  | (fexp_tabs e) => fexp_tabs (subst_exp_in_fexp e_5 x5 e)
  | (fexp_tapp e T) => fexp_tapp (subst_exp_in_fexp e_5 x5 e) T
  | (fexp_inl e) => fexp_inl (subst_exp_in_fexp e_5 x5 e)
  | (fexp_inr e) => fexp_inr (subst_exp_in_fexp e_5 x5 e)
  | (fexp_case e e2 e3) => fexp_case (subst_exp_in_fexp e_5 x5 e) (subst_exp_in_fexp e_5 x5 e2) (subst_exp_in_fexp e_5 x5 e3)
  | (fexp_proj1 e) => fexp_proj1 (subst_exp_in_fexp e_5 x5 e)
  | (fexp_proj2 e) => fexp_proj2 (subst_exp_in_fexp e_5 x5 e)
  | (fexp_pair e1 e2) => fexp_pair (subst_exp_in_fexp e_5 x5 e1) (subst_exp_in_fexp e_5 x5 e2)
end.

Fixpoint subst_typ_in_fexp (T_5:ftyp) (X5:typvar) (e_5:fexp) {struct e_5} : fexp :=
  match e_5 with
  | (fexp_var_b nat) => fexp_var_b nat
  | (fexp_var_f x) => fexp_var_f x
  | (fexp_abs T e) => fexp_abs (subst_typ_in_ftyp T_5 X5 T) (subst_typ_in_fexp T_5 X5 e)
  | (fexp_app e1 e2) => fexp_app (subst_typ_in_fexp T_5 X5 e1) (subst_typ_in_fexp T_5 X5 e2)
  | (fexp_tabs e) => fexp_tabs (subst_typ_in_fexp T_5 X5 e)
  | (fexp_tapp e T) => fexp_tapp (subst_typ_in_fexp T_5 X5 e) (subst_typ_in_ftyp T_5 X5 T)
  | (fexp_inl e) => fexp_inl (subst_typ_in_fexp T_5 X5 e)
  | (fexp_inr e) => fexp_inr (subst_typ_in_fexp T_5 X5 e)
  | (fexp_case e e2 e3) => fexp_case (subst_typ_in_fexp T_5 X5 e) (subst_typ_in_fexp T_5 X5 e2) (subst_typ_in_fexp T_5 X5 e3)
  | (fexp_proj1 e) => fexp_proj1 (subst_typ_in_fexp T_5 X5 e)
  | (fexp_proj2 e) => fexp_proj2 (subst_typ_in_fexp T_5 X5 e)
  | (fexp_pair e1 e2) => fexp_pair (subst_typ_in_fexp T_5 X5 e1) (subst_typ_in_fexp T_5 X5 e2)
end.


(** definitions *)

(* defns Jwf_typ *)
Inductive wf : fenv -> ftyp -> Prop :=    (* defn wf *)
 | wf_typ_unit : forall (E:fenv),
     wf E ftyp_unit
 | wf_typ_var : forall (E:fenv) (X:typvar),
      binds ( X ) ( bind_tvar_empty ) ( E )  ->
     wf E (ftyp_var_f X)
 | wf_typ_arrow : forall (E:fenv) (T1 T2:ftyp),
     wf E T1 ->
     wf E T2 ->
     wf E (ftyp_arrow T1 T2)
 | wf_typ_all : forall (L:vars) (E:fenv) (T:ftyp),
      ( forall X , X \notin  L  -> wf  ( X ~ bind_tvar_empty  ++  E )   ( open_ftyp_wrt_ftyp T (ftyp_var_f X) )  )  ->
     wf E (ftyp_all T)
 | wf_typ_sum : forall (E:fenv) (T1 T2:ftyp),
     wf E T1 ->
     wf E T2 ->
     wf E (ftyp_sum T1 T2)
 | wf_typ_prod : forall (E:fenv) (T1 T2:ftyp),
     wf E T1 ->
     wf E T2 ->
     wf E (ftyp_prod T1 T2).

(* defns Jwf_env *)
Inductive wf_env : fenv -> Prop :=    (* defn wf_env *)
 | wf_env_empty : 
     wf_env  nil 
 | wf_env_sub : forall (E:fenv) (X:typvar),
     wf_env E ->
      ( X  `notin` dom ( E ))  ->
     wf_env  ( X ~ bind_tvar_empty  ++  E ) 
 | wf_env_typ : forall (E:fenv) (x:expvar) (T:ftyp),
     wf_env E ->
     wf E T ->
      ( x  `notin` dom ( E ))  ->
     wf_env  ( x ~ (bind_typ T)  ++  E ) .

(* defns Jtyping *)
Inductive typing : fenv -> fexp -> ftyp -> Prop :=    (* defn typing *)
 | typing_var : forall (E:fenv) (x:expvar) (T:ftyp),
     wf_env E ->
      binds ( x ) ( (bind_typ T) ) ( E )  ->
     typing E (fexp_var_f x) T
 | typing_abs : forall (L:vars) (E:fenv) (T1:ftyp) (e:fexp) (T2:ftyp),
      ( forall x , x \notin  L  -> typing  ( x ~ (bind_typ T1)  ++  E )   ( open_fexp_wrt_fexp e (fexp_var_f x) )  T2 )  ->
     typing E (fexp_abs T1 e) (ftyp_arrow T1 T2)
 | typing_app : forall (E:fenv) (e1 e2:fexp) (T2 T1:ftyp),
     typing E e1 (ftyp_arrow T1 T2) ->
     typing E e2 T1 ->
     typing E (fexp_app e1 e2) T2
 | typing_tabs : forall (L:vars) (E:fenv) (e:fexp) (T:ftyp),
      ( forall X , X \notin  L  -> typing  ( X ~ bind_tvar_empty  ++  E )   ( open_fexp_wrt_ftyp e (ftyp_var_f X) )   ( open_ftyp_wrt_ftyp T (ftyp_var_f X) )  )  ->
     typing E (fexp_tabs e) (ftyp_all T)
 | typing_tapp : forall (E:fenv) (e1:fexp) (T2 T1:ftyp),
     lc_ftyp T2 ->
     typing E e1 (ftyp_all T1) ->
     typing E (fexp_tapp e1 T2)  (open_ftyp_wrt_ftyp  T1   T2 ) 
 | typing_inl : forall (E:fenv) (e1:fexp) (T1 T2:ftyp),
     typing E e1 T1 ->
     wf E T2 ->
     typing E (fexp_inl e1) (ftyp_sum T1 T2)
 | typing_inr : forall (E:fenv) (e1:fexp) (T1 T2:ftyp),
     typing E e1 T2 ->
     wf E T1 ->
     typing E (fexp_inr e1) (ftyp_sum T1 T2)
 | typing_case : forall (L:vars) (E:fenv) (e1 e2 e3:fexp) (T T1 T2:ftyp),
     typing E e1 (ftyp_sum T1 T2) ->
      ( forall x , x \notin  L  -> typing  ( x ~ (bind_typ T1)  ++  E )   ( open_fexp_wrt_fexp e2 (fexp_var_f x) )  T )  ->
      ( forall y , y \notin  L  -> typing  ( y ~ (bind_typ T2)  ++  E )   ( open_fexp_wrt_fexp e3 (fexp_var_f y) )  T )  ->
     typing E (fexp_case e1 e2 e3) T
 | typing_pair : forall (E:fenv) (e1 e2:fexp) (T1 T2:ftyp),
     typing E e1 T1 ->
     typing E e2 T2 ->
     typing E (fexp_pair e1 e2) (ftyp_prod T1 T2)
 | typing_proj1 : forall (E:fenv) (e:fexp) (T1 T2:ftyp),
     typing E e (ftyp_prod T1 T2) ->
     typing E (fexp_proj1 e) T1
 | typing_proj2 : forall (E:fenv) (e:fexp) (T2 T1:ftyp),
     typing E e (ftyp_prod T1 T2) ->
     typing E (fexp_proj2 e) T2.

(* defns Jop *)
Inductive red : fexp -> fexp -> Prop :=    (* defn red *)
 | red_app_1 : forall (e1 e2 e1':fexp),
     lc_fexp e2 ->
     red e1 e1' ->
     red (fexp_app e1 e2) (fexp_app e1' e2)
 | red_app_2 : forall (e2 e2' v1:fexp),
     Is_true (is_fvalue_of_fexp v1) ->
     lc_fexp v1 ->
     red e2 e2' ->
     red (fexp_app v1 e2) (fexp_app v1 e2')
 | red_tapp_1 : forall (e1:fexp) (T:ftyp) (e1':fexp),
     lc_ftyp T ->
     red e1 e1' ->
     red (fexp_tapp e1 T) (fexp_tapp e1' T)
 | red_abs : forall (T:ftyp) (e1 v2:fexp),
     Is_true (is_fvalue_of_fexp v2) ->
     lc_ftyp T ->
     lc_fexp (fexp_abs T e1) ->
     lc_fexp v2 ->
     red (fexp_app  ( (fexp_abs T e1) )  v2)  (open_fexp_wrt_fexp  e1   v2 ) 
 | red_tabs : forall (e1:fexp) (T2:ftyp),
     lc_fexp (fexp_tabs e1) ->
     lc_ftyp T2 ->
     red (fexp_tapp  ( (fexp_tabs e1) )  T2)  (open_fexp_wrt_ftyp  e1   T2 ) 
 | red_inl_1 : forall (e1 e1':fexp),
     red e1 e1' ->
     red (fexp_inl e1) (fexp_inl e1')
 | red_inr_1 : forall (e1 e1':fexp),
     red e1 e1' ->
     red (fexp_inr e1) (fexp_inr e1')
 | red_case_1 : forall (e1 e2 e3 e1':fexp),
     lc_fexp (fexp_case e1 e2 e3) ->
     lc_fexp (fexp_case e1 e2 e3) ->
     red e1 e1' ->
     red (fexp_case e1 e2 e3) (fexp_case e1' e2 e3)
 | red_case_inl : forall (e2 e3 v1:fexp),
     Is_true (is_fvalue_of_fexp v1) ->
     lc_fexp (fexp_case (fexp_inl v1) e2 e3) ->
     lc_fexp (fexp_case (fexp_inl v1) e2 e3) ->
     lc_fexp v1 ->
     red (fexp_case (fexp_inl v1) e2 e3)  (open_fexp_wrt_fexp  e2   v1 ) 
 | red_case_inr : forall (e2 e3 v1:fexp),
     Is_true (is_fvalue_of_fexp v1) ->
     lc_fexp (fexp_case (fexp_inr v1) e2 e3) ->
     lc_fexp (fexp_case (fexp_inr v1) e2 e3) ->
     lc_fexp v1 ->
     red (fexp_case (fexp_inr v1) e2 e3)  (open_fexp_wrt_fexp  e3   v1 ) 
 | red_proj1_v : forall (v2 v1:fexp),
     Is_true (is_fvalue_of_fexp v1) ->
     Is_true (is_fvalue_of_fexp v2) ->
     lc_fexp v2 ->
     lc_fexp v1 ->
     red (fexp_proj1 (fexp_pair v1 v2)) v1
 | red_proj2_v : forall (v1 v2:fexp),
     Is_true (is_fvalue_of_fexp v1) ->
     Is_true (is_fvalue_of_fexp v2) ->
     lc_fexp v1 ->
     lc_fexp v2 ->
     red (fexp_proj2 (fexp_pair v1 v2)) v2
 | red_proj1 : forall (e e':fexp),
     red e e' ->
     red (fexp_proj1 e) (fexp_proj1 e')
 | red_proj2 : forall (e e':fexp),
     red e e' ->
     red (fexp_proj2 e) (fexp_proj2 e')
 | red_pair1 : forall (e1 e2 e1':fexp),
     lc_fexp e2 ->
     red e1 e1' ->
     red (fexp_pair e1 e2) (fexp_pair e1' e2)
 | red_pair2 : forall (e1 e2 e2':fexp),
     lc_fexp e1 ->
     red e2 e2' ->
     red (fexp_pair e1 e2) (fexp_pair e1 e2').


(** infrastructure *)
#[export] Hint Constructors wf wf_env typing red lc_ftyp lc_binding lc_fexp : core.


