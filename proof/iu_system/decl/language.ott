metavar typvar, X, Y, Z     ::= {{ repr-locally-nameless }}
metavar stypvar, SX, SY, SZ ::= {{ coq var }}
metavar expvar, x, y, z     ::= {{ repr-locally-nameless }}

grammar

dtyp, T, S, U :: dtyp_ ::=
  | UNIT           ::   :: unit
  | TOP            ::   :: top
  | BOT            ::   :: bot
  | X              ::   :: var
  | SX             ::   :: svar
  | T1 -> T2       ::   :: arrow
  | ∀ X . T        ::   :: all  (+ bind X in T +)
  | T1 + T2        ::   :: union
  | T1 * T2        ::   :: intersection
  | ( T )          :: S :: paren {{ coq ([[T]]) }}
  | { T2 / X } T1  :: M :: subst {{ coq (open_dtyp_wrt_dtyp [[X T1]] [[T2]]) }}

dbody :: dbody_ ::= 
  | e : T ::  :: anno

dexp, e, f, g :: dexp_ ::=
  | unit                                ::   :: unit 
  | top                                 ::   :: top
  | x                                   ::   :: var
  | \ x . e                             ::   :: abs  (+ bind x in e +)
  | e1 e2                               ::   :: app
  | \ X . dbody                         ::   :: tabs (+ bind X in dbody +) 
  | e @ T                               ::   :: tapp
  | e : T                               ::   :: anno
  | ( e )                               :: S :: paren  {{ coq ([[e]]) }}
  | { e2 / x } e1                       :: M :: subst1 {{ coq (open_dexp_wrt_dexp [[x e1]] [[e2]]) }}
  | { T2 / X } e1                       :: M :: subst2 {{ coq (open_dexp_wrt_dtyp [[X e1]] [[T2]]) }}

binding, b :: dbind_ ::=
  | : ▪  ::   :: tvar_empty
  | : ~▪ ::   :: stvar_empty
  | : T  ::   :: typ

substitutions
  single T X  :: dsubst_tv_in
  single T SX :: dsubst_stv_in
  single e x  :: dsubst_v_in

freevars
  T X  :: ftv_in
  T SX :: fstv_in
  e x  :: fv_in

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

denv, E, F, G:: '' ::= {{ coq list (atom*binding) }}
  | empty    ::   :: empty {{ coq nil }}
  | E , x b  ::   :: cons1 {{ coq ([[x]]~[[b]] ++ [[E]])  }}
  | E , X b  ::   :: cons2 {{ coq ([[X]]~[[b]] ++ [[E]])  }}
  | E , SX b ::   :: cons3 {{ coq ([[SX]]~[[b]] ++ [[E]]) }}

dvalue, v :: dvalue_ ::=
  | unit             ::   :: unit
  | \ x . e          ::   :: abs  (+ bind x in e +)
  | \ X . dbody      ::   :: tabs (+ bind X in dbody +)
  | top              ::   :: top
  | v : T            ::   :: anno

dcont, c :: 'dcont_' ::=
  | Done                :: :: done
  | _ . e1 & e2 =>=> c  :: :: app
  | _ <: A              :: :: sub

dwork, w :: 'dwork_' ::=
  | e => c              ::   :: infer
  | e <= T              ::   :: check
  | T . e1 & e2 =>=> c  ::   :: infer_app
  | T1 <: T2            ::   :: sub
  | c $ T               ::   :: apply

formula :: formula_ ::=
  | judgement        ::   :: judgement
  | ( x b )  in E    ::   :: binds1 {{ coq binds ([[x]])  ([[b]]) ([[E]]) }}
  | ( X b )  in E    ::   :: binds2 {{ coq binds ([[X]])  ([[b]]) ([[E]]) }}
  | ( SX b ) in E    ::   :: binds3 {{ coq binds ([[SX]]) ([[b]]) ([[E]]) }}
  | uniq E           ::   :: uniq   {{ coq uniq ([[E]]) }}
  | x  `notin` dom E ::   :: fresh1 {{ coq ([[x]]  `notin` dom ([[E]])) }}
  | X  `notin` dom E ::   :: fresh2 {{ coq ([[X]]  `notin` dom ([[E]])) }}
  | SX `notin` dom E ::   :: fresh3 {{ coq ([[SX]] `notin` dom ([[E]])) }}
  | X in T           ::   :: appear1 {{ coq [[X]] `in` ftv_in_dtyp [[T]]}}
  | SX in T          ::   :: appear2 {{ coq [[SX]] `in` fstv_in_dtyp [[T]]}}
  | T ¬= TOP         ::   :: neqtop  {{ coq ~ ([[T]] = dtyp_top)}}
 
subrules
  v <:: e


embed {{ coq


}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jdstrong_in :: '' ::=

defn
X ∈ₛ T :: :: ds_in :: 'dsin_' by

------------------------ :: var
X ∈ₛ X 

X ∈ₛ T1
------------------------ :: arrow1
X ∈ₛ T1 -> T2 

X ∈ₛ T2
------------------------ :: arrow2
X ∈ₛ T1 -> T2 

X ∈ₛ T
------------------------ :: all
X ∈ₛ ∀ Y . T

X ∈ₛ T1
X ∈ₛ T2
------------------------ :: union
X ∈ₛ T1 + T2

X ∈ₛ T1
X ∈ₛ T2
------------------------ :: intersection
X ∈ₛ T1 * T2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jdstrong_in_sty :: '' ::=

defn
SX ∈ₛ T :: :: ds_in_s :: 'dsins_' by

------------------------ :: var
SX ∈ₛ SX

SX ∈ₛ T1
------------------------ :: arrow1
SX ∈ₛ T1 -> T2 

SX ∈ₛ T2
------------------------ :: arrow2
SX ∈ₛ T1 -> T2 

SX ∈ₛ T
------------------------ :: all
SX ∈ₛ ∀ Y . T

SX ∈ₛ T1
SX ∈ₛ T2
------------------------ :: union
SX ∈ₛ T1 + T2

SX ∈ₛ T1
SX ∈ₛ T2
------------------------ :: intersection
SX ∈ₛ T1 * T2


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
Jdneq_forall :: '' ::=

defn
T ¬= ∀ :: :: dneq_forall :: 'dneqforall_' by

------------------------ :: unit
UNIT ¬= ∀

------------------------ :: top
TOP ¬= ∀

------------------------ :: bot
BOT ¬= ∀

------------------------ :: var
X ¬= ∀

------------------------ :: svar
SX ¬= ∀

------------------------ :: arrow
T1 -> T2 ¬= ∀

------------------------ :: union
T1 + T2 ¬= ∀

------------------------ :: intersection
T1 * T2 ¬= ∀


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jdneq_intersection :: '' ::=

defn
T ¬= * :: :: dneq_intersection :: 'dneqintersection_' by

------------------------ :: unit
UNIT ¬= *

------------------------ :: top
TOP ¬= * 

------------------------ :: bot
BOT ¬= *

------------------------ :: var
X ¬= *

------------------------ :: svar
SX ¬= *

------------------------ :: arrow
T1 -> T2 ¬= *

------------------------ :: forall
∀ X . T ¬= *

------------------------ :: union
T1 + T2 ¬= *

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jdneq_union :: '' ::=

defn
T ¬= + :: :: dneq_union :: 'dnequnion_' by

------------------------ :: unit
UNIT ¬= +

------------------------ :: top
TOP ¬= +

------------------------ :: bot
BOT ¬= +

------------------------ :: var
X ¬= +

------------------------ :: svar
SX ¬= +

------------------------ :: arrow
T1 -> T2 ¬= +

------------------------ :: forall
∀ X . T ¬= +

------------------------ :: intersection
T1 * T2 ¬= +

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jdwf_typ :: '' ::=

defn
E |- T :: :: dwf_typ :: 'dwftyp_' by

--------- :: unit
E |- UNIT 

--------- :: bot
E |- BOT 

--------- :: top
E |- TOP

(X : ▪) in E
-------------- :: var
E |- X

(SX : ~▪) in E 
-------------- :: stvar 
E |- SX

E |- T1
E |- T2
-------------- :: arrow
E |- T1 -> T2

X ∈ₛ T
E, X : ▪ |- T
-------------------- :: all
E |- ∀ X . T

E |- T1
E |- T2
------------- :: union
E |- T1 + T2

E |- T1
E |- T2 
------------- :: intersection
E |- T1 * T2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jdwf_env :: '' ::=

defn
|- E :: :: dwf_env :: 'dwfenv_' by

--------- :: empty
|- empty

|- E
X `notin` dom E
---------------- :: tvar
|- E , X : ▪

|- E
SX `notin` dom E 
---------------- :: stvar
|- E , SX : ~▪

|- E
E |- T
x `notin` dom E
---------------- :: typ
|- E , x : T


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns 
Jdmono_typ :: '' ::= 

defn 
mono T :: :: dmono_typ :: 'dmonotyp_' by 

--------------- :: unit
mono UNIT

--------------- :: tvar
mono X

mono T1
mono T2
--------------- :: arrow
mono T1 -> T2

mono T1 
mono T2 
--------------- :: intersection
mono T1 * T2

mono T1 
mono T2 
--------------- :: union
mono T1 + T2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jdsub :: '' ::=

defn
E |- T1 <: T2 :: :: dsub :: 'dsub_' by

E |- S
-------------- :: top
E |- S <: TOP

E |- T
------------------- :: bot
E |- BOT <: T

------------------- :: unit
E |- UNIT <: UNIT

E |- X
------------ :: refl_tvar
E |- X <: X

E |- SX 
--------------- :: refl_stvar
E |- SX <: SX 

E |- T1 <: S1
E |- S2 <: T2
-------------------------- :: arrow
E |- S1 -> S2 <: T1 -> T2

E , SX : ~▪ |- { SX / X } S <: { SX / X } T
-------------------------------------------- :: forall
E |- ∀ X. S <: ∀ X. T

T1 ¬= ∀ 
T1 ¬= *
T1 ¬= +
T1 ¬= TOP  
E |- T2
mono T2
E |- { T2 / X } S <: T1
---------------------------- :: foralll
E |- ∀ X . S <: T1

E |- S <: T1
E |- S <: T2
------------------------ :: intersection1
E |- S <: T1 * T2

% T ¬= *
E |- S1 <: T
E |- S2
------------------------ :: intersection2
E |- S1 * S2 <: T

% T ¬= *
E |- S2 <: T
E |- S1
------------------------ :: intersection3
E |- S1 * S2 <: T

% S ¬= +
E |- S <: T1
E |- T2
------------------------ :: union1
E |- S <: T1 + T2

% S ¬= +
E |- S <: T2
E |- T1
------------------------ :: union2
E |- S <: T1 + T2

E |- S1 <: T
E |- S2 <: T
------------------------ :: union3
E |- S1 + S2 <: T

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jdsub_stable :: '' ::=

defn
E |- T1 <:ₛ T2 :: :: dsub_stable :: 'dsubstable_' by

E |- S
-------------- :: top
E |- S <:ₛ TOP

E |- T
------------------- :: bot
E |- BOT <:ₛ T

------------------- :: unit
E |- UNIT <:ₛ UNIT

E |- T1 <:ₛ S1
E |- S2 <:ₛ T2
-------------------------- :: arrow
E |- S1 -> S2 <:ₛ T1 -> T2

E |- U
E |- { U / X } S <:ₛ { U / X } T
-------------------------------------------- :: forall
E |- ∀ X. S <:ₛ ∀ X. T

T1 ¬= ∀ 
T1 ¬= *
T1 ¬= +
T1 ¬= TOP  
E |- U
mono U
E |- { U / X } S <:ₛ T
---------------------------- :: foralll
E |- ∀ X . S <:ₛ T

E |- S <:ₛ T1
E |- S <:ₛ T2
------------------------ :: intersection1
E |- S <:ₛ T1 * T2

% T ¬= *
E |- S1 <:ₛ T
E |- S2
------------------------ :: intersection2
E |- S1 * S2 <:ₛ T

% T ¬= *
E |- S2 <:ₛ T
E |- S1
------------------------ :: intersection3
E |- S1 * S2 <:ₛ T

% S ¬= +
E |- S <:ₛ T1
E |- T2
------------------------ :: union1
E |- S <:ₛ T1 + T2

% S ¬= +
E |- S <:ₛ T2
E |- T1
------------------------ :: union2
E |- S <:ₛ T1 + T2

E |- S1 <:ₛ T
E |- S2 <:ₛ T
------------------------ :: union3
E |- S1 + S2 <:ₛ T


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jdtyping :: '' ::=

defn 
E |- e => T :: :: dinf :: 'dinf_' by 

|- E
(x : T) in E
-------------- :: var
E |- x => T

E |- T
E |- e <= T
------------------ :: anno
E |- (e : T) => T

|- E
--------------------------- :: unit
E |- unit => UNIT

E |- e => BOT
--------------------------- :: bot
E |- e @ T => BOT

E |- e1 => T2
E |- T2 • e2 =>=> T1
--------------------------- :: app
E |- ( e1 e2 ) => T1

E , X : ▪ |- e : T1 <= T2
-------------------------------- :: tabs
E |- \ X . e : T1 => ∀ X . T2

E |- e1 => ∀ X . T1
E |- T2
----------------------------- :: tapp 
E |- e1 @ T2 => {T2 / X} T1


% disable inferring mono types 
% mono (T1 -> T2)
% E |- T1 -> T2
% E, x : T1 |- e <= T2
% --------------------------- :: abs
% E |- \ x . e => T1 -> T2

defn
E |- e <= T :: :: dchk :: 'dchk_' by

% use the following rule instead
% TODO: check E |- e
% |- E 
% --------------------------- :: top
% E |- e <= TOP

E, x : BOT |- e <= TOP
--------------------------- :: top_abs
E |- \ x . e <= TOP

E |- T1 -> T2
E, x : T1 |- e <= T2
--------------------------- :: abs
E |- \ x . e <= T1 -> T2

E |- e1 => T1
E |- T1 • e2 =>=> T2
------------------------ :: app
E |- e1 e2 <= T2

E, X : ▪ |- e <= T
--------------------------- :: all
E |- e <= ∀ X . T

E |- e => S
E |- S <: T
---------------- :: sub
E |- e <= T

E |- e <= S
E |- e <= T
------------------- :: intersection
E |- e <= S * T

E |- e <= S
E |- T
------------------- :: union1
E |- e <= S + T

E |- e <= T
E |- S
------------------- :: union2
E |- e <= S + T

defn 
E |- T1 • e =>=> T2 :: :: dinfapp :: 'dinfapp_' by

E |- e <= T1
-------------------------------- :: arrow
E |- ( T1 -> T2 ) • e =>=> T2

mono T3
E |- T3 
E |- { T3 / X } T1 • e =>=> T2
-------------------------------- :: forall
E |- ( ∀ X . T1 ) • e =>=> T2

E |- e <= TOP
-------------------------------- :: bot
E |- BOT • e =>=> BOT


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% defns
% Jneq_abs :: '' ::=

% defn
% e ¬= λ :: :: neq_abs :: 'neq_abs_' by

% ------------ :: var
% x ¬= λ

% ---------------  :: app
% ( e1 e2 ) ¬= λ

% ------------------ :: tabs
% \ X . e : T ¬= λ

% --------------  :: tapp
% e @ T ¬= λ

% --------------- :: anno
% e : T ¬= λ


% defns
% Jneq_tabs :: '' ::=

% defn
% e ¬= Λ :: :: neq_tabs :: 'neq_tabs_' by

% ------------ :: var
% x ¬= Λ

% -----------------  :: app
% ( e1 e2 ) ¬= Λ

% ------------------ :: abs
% \ x . e ¬= Λ

% --------------  :: tapp
% e @ T ¬= Λ

% --------------- :: anno
% e : T ¬= Λ
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jdexored :: '' ::=

defn
e1 --> e2 :: :: dexp_red :: 'dexpred_' by

e1 --> e1'
----------------- :: app1
e1 e2 --> e1' e2

e2 --> e2'
----------------- :: app2
v1 e2 --> v1 e2'

e1 --> e1'
----------------------- :: tapp
e1 @ T  --> e1' @ T 

------------------------------- :: abs
(\ x . e) v  --> {v / x} e

------------------------------------------------------------- :: tabs
(\ X . e : T1 ) @ T2 --> {T2 / X} (e : T1) 

e --> e' 
-------------------- :: anno
e : T --> e' : T   

% v ¬= λ 
% -------------------- :: app_top
% v e --> top

% v ¬= Λ 
% -------------------- :: app_top
% v @ T --> top
