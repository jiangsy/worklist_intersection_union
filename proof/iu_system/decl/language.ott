metavar typvar, X, Y, Z     ::= {{ repr-locally-nameless }}
metavar stypvar, SX, SY, SZ ::= {{ coq var }}
metavar expvar, x, y, z     ::= {{ repr-locally-nameless }}

grammar

dtyp, T, S, U :: dtyp_ ::=
  | UNIT           ::   :: unit
  | TOP            ::   :: top
  | BOT            ::   :: bot
  | X              ::   :: var
  | SX             ::   :: svar
  | T1 -> T2       ::   :: arrow
  | ∀ X . T        ::   :: all  (+ bind X in T +)
  | T1 + T2        ::   :: union
  | T1 * T2        ::   :: intersection
  | ( T )          :: S :: paren {{ coq ([[T]]) }}
  | { T2 / X } T1  :: M :: subst {{ coq (open_dtyp_wrt_dtyp [[X T1]] [[T2]]) }}

dbody :: dbody_ ::= 
  | e : T ::  :: anno

dexp, e, f, g :: dexp_ ::=
  | unit                                ::   :: unit 
  | top                                 ::   :: top
  | x                                   ::   :: var
  | \ x . e                             ::   :: abs  (+ bind x in e +)
  | e1 e2                               ::   :: app
  | \ X . dbody                         ::   :: tabs (+ bind X in dbody +) 
  | e @ T                               ::   :: tapp
  | e : T                               ::   :: anno
  | ( e )                               :: S :: paren  {{ coq ([[e]]) }}
  | { e2 / x } e1                       :: M :: subst1 {{ coq (open_dexp_wrt_dexp [[x e1]] [[e2]]) }}
  | { T2 / X } e1                       :: M :: subst2 {{ coq (open_dexp_wrt_dtyp [[X e1]] [[T2]]) }}

binding, b :: dbind_ ::=
  | : ▪  ::   :: tvar_empty
  | : ~▪ ::   :: stvar_empty
  | : T  ::   :: typ

substitutions
  single T X  :: dsubst_tv_in
  single T SX :: dsubst_stv_in
  single e x  :: dsubst_v_in

freevars
  T X  :: ftv_in
  T SX :: fstv_in
  e x  :: fv_in

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

denv, E, F, G:: '' ::= {{ coq list (atom*binding) }}
  | empty    ::   :: empty {{ coq nil }}
  | E , x b  ::   :: cons1 {{ coq ([[x]]~[[b]] ++ [[E]])  }}
  | E , X b  ::   :: cons2 {{ coq ([[X]]~[[b]] ++ [[E]])  }}
  | E , SX b ::   :: cons3 {{ coq ([[SX]]~[[b]] ++ [[E]]) }}

dvalue, v :: dvalue_ ::=
  | unit             ::   :: unit
  | \ x . e          ::   :: abs  (+ bind x in e +)
  | \ X . dbody      ::   :: tabs (+ bind X in dbody +)
  | top              ::   :: top
  | v : T            ::   :: anno

formula :: formula_ ::=
  | judgement        ::   :: judgement
  | ( x b )  in E    ::   :: binds1 {{ coq binds ([[x]])  ([[b]]) ([[E]]) }}
  | ( X b )  in E    ::   :: binds2 {{ coq binds ([[X]])  ([[b]]) ([[E]]) }}
  | ( SX b ) in E    ::   :: binds3 {{ coq binds ([[SX]]) ([[b]]) ([[E]]) }}
  | uniq E           ::   :: uniq   {{ coq uniq ([[E]]) }}
  | x  `notin` dom E ::   :: fresh1 {{ coq ([[x]]  `notin` dom ([[E]])) }}
  | X  `notin` dom E ::   :: fresh2 {{ coq ([[X]]  `notin` dom ([[E]])) }}
  | SX `notin` dom E ::   :: fresh3 {{ coq ([[SX]] `notin` dom ([[E]])) }}

subrules
  v <:: e

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jdwf_typ :: '' ::=

defn
E |- T :: :: dwf_typ :: 'dwf_typ_' by

--------- :: unit
E |- UNIT 

--------- :: bot
E |- BOT 

--------- :: top
E |- TOP

(X : ▪) in E
-------------- :: var
E |- X

(SX : ~▪) in E 
-------------- :: stvar 
E |- SX

E |- T1
E |- T2
-------------- :: arrow
E |- T1 -> T2

E, X : ▪ |- T
-------------------- :: all
E |- ∀ X . T

E |- T1
E |- T2
------------- :: union
E |- T1 + T2

E |- T1
E |- T2 
------------- :: intersection
E |- T1 * T2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns 
Jdmono_typ :: '' ::= 

defn 
mono T :: :: dmono_typ :: 'dmono_typ_' by 

--------------- :: unit
mono UNIT

--------------- :: tvar
mono X

mono T1
mono T2
--------------- :: arrow
mono T1 -> T2

mono T1 
mono T2 
--------------- :: intersection
mono T1 * T2

mono T1 
mono T2 
--------------- :: union
mono T1 + T2


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jdwf_env :: '' ::=

defn
|- E :: :: dwf_env :: 'dwf_env_' by

--------- :: empty
|- empty

|- E
X `notin` dom E
---------------- :: tvar
|- E , X : ▪

|- E
SX `notin` dom E 
---------------- :: stvar
|- E , SX : ~▪

|- E
E |- T
x `notin` dom E
---------------- :: typ
|- E , x : T

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jdsub :: '' ::=

defn
E |- T1 <: T2 :: :: dsub :: 'dsub_' by

|- E
E |- S
-------------- :: top
E |- S <: TOP

|- E 
E |- T
------------------- :: bot
E |- BOT <: T

|- E
------------------- :: unit
E |- UNIT <: UNIT

|- E
E |- X
------------ :: refl_tvar
E |- X <: X

|- E 
E |- SX 
--------------- :: refl_stvar
E |- SX <: SX 

E |- T1 <: S1
E |- S2 <: T2
-------------------------- :: arrow
E |- S1 -> S2 <: T1 -> T2

E , SX : ~▪ |- { SX / X } S <: { SX / X } T
-------------------------------------------- :: forall
E |- ∀ X. S <: ∀ X. T

E |- T2
mono T2
E |- { T2 / X } S <: T1
---------------------------- :: foralll
E |- ∀ X . S <: T1

E |- S <: T1
E |- S <: T2
------------------------ :: intersection_1
E |- S <: T1 * T2

E |- S1 <: T
E |- S2
------------------------ :: intersection_2
E |- S1 * S2 <: T

E |- S2 <: T
E |- S1
------------------------ :: intersection_3
E |- S1 * S2 <: T

E |- S <: T1
E |- T2
------------------------ :: union_1
E |- S <: T1 + T2

E |- S <: T2
E |- T1
------------------------ :: union_2
E |- S <: T1 + T2

E |- S1 <: T
E |- S2 <: T
------------------------ :: union_3
E |- S1 + S2 <: T

defns
Jdneq_forall :: '' ::=

defn
T ¬= ∀ :: :: dneq_forall :: 'dneq_forall' by

------------------------ :: unit
UNIT ¬= ∀

------------------------ :: top
TOP ¬= ∀

------------------------ :: bot
BOT ¬= ∀

------------------------ :: var
X ¬= ∀

------------------------ :: svar
SX ¬= ∀

------------------------ :: arrow
T1 -> T2 ¬= ∀

------------------------ :: union
T1 + T2 ¬= ∀

------------------------ :: intersection
T1 * T2 ¬= ∀

defns
Jdtyping :: '' ::=

defn 
E |- e => T :: :: d_infer :: 'dinf_' by 

|- E
(x : T) in E
-------------- :: var
E |- x => T

E |- T
E |- e <= T
------------------ :: anno
E |- (e : T) => T

|- E
--------------------------- :: unit
E |- unit => UNIT

E |- e => BOT
--------------------------- :: bot
E |- e @ T => BOT

E, X : ▪ |- e : T1 <= T2
-------------------------------- :: tabs
E |- \ X . e : T1 => ∀ X . T2

E |- e1 => ∀ X . T1
E |- T2
----------------------------- :: tapp 
E |- e1 @ T2 => {T2 / X} T1

% disable inferring mono types 
% mono (T1 -> T2)
% E |- T1 -> T2
% E, x : T1 |- e <= T2
% --------------------------- :: abs
% E |- \ x . e => T1 -> T2

defn
E |- e <= T :: :: d_check :: 'dchk_' by

% use the following rule instead
% TODO: check E |- e
% |- E 
% --------------------------- :: top
% E |- e <= TOP

E, x : BOT |- e <= TOP
--------------------------- :: top_lambda
E |- \ x . e <= TOP

E |- T1 -> T2
E, x : T1 |- e <= T2
--------------------------- :: abs
E |- \ x . e <= T1 -> T2

E |- e1 => T1
E |- T1 ∘ e2 =>=> T2
------------------------ :: app
E |- e1 e2 <= T2

E |- e => S
E |- S <: T
---------------- :: sub
E |- e <= T

defn 
E |- T1 ∘ e =>=> T2 :: :: d_infer_app :: 'dinfapp_' by

E |- e <= T1
-------------------------------- :: arrow
E |- ( T1 -> T2 ) ∘ e =>=> T2

mono T3
E |- T3 
E |- { T3 / X } T1 ∘ e =>=> T2
-------------------------------- :: forall
E |- ( ∀ X . T1 ) ∘ e =>=> T2

E |- e <= TOP
-------------------------------- :: bot
E |- BOT ∘ e =>=> BOT


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% defns
% Jneq_abs :: '' ::=

% defn
% e ¬= λ :: :: neq_abs :: 'neq_abs_' by

% ------------ :: var
% x ¬= λ

% ---------------  :: app
% ( e1 e2 ) ¬= λ

% ------------------ :: tabs
% \ X . e : T ¬= λ

% --------------  :: tapp
% e @ T ¬= λ

% --------------- :: anno
% e : T ¬= λ


% defns
% Jneq_tabs :: '' ::=

% defn
% e ¬= Λ :: :: neq_tabs :: 'neq_tabs_' by

% ------------ :: var
% x ¬= Λ

% -----------------  :: app
% ( e1 e2 ) ¬= Λ

% ------------------ :: abs
% \ x . e ¬= Λ

% --------------  :: tapp
% e @ T ¬= Λ

% --------------- :: anno
% e : T ¬= Λ
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jop :: '' ::=

defn
e1 --> e2 :: :: red :: 'red_' by

e1 --> e1'
----------------- :: app_1
e1 e2 --> e1' e2

e2 --> e2'
----------------- :: app_2
v1 e2 --> v1 e2'

e1 --> e1'
----------------------- :: tapp_1
e1 @ T  --> e1' @ T 

------------------------------- :: abs
(\ x . e) v  --> {v / x} e

------------------------------------------------------------- :: tabs
(\ X . e : T1 ) @ T2 --> {T2 / X} (e : T1) 

e --> e' 
-------------------- :: anno
e : T --> e' : T   

% v ¬= λ 
% -------------------- :: app_top
% v e --> top

% v ¬= Λ 
% -------------------- :: app_top
% v @ T --> top
