
metavar x, y, z ::= {{ repr-locally-nameless }}
metavar ex, ey, ez ::= {{ coq var }}
metavar sx, sy, sz ::= {{ coq var }}


grammar

algo_type, t, A, B :: 'algo_t_' ::= 
  | int           ::   :: int
  | ⊤             ::   :: top
  | ⊥             ::   :: bot 
  | forall x . t  ::   :: forall (+ bind x in t +) 
  | t1 -> t2      ::   :: arrow 
  | t1 ∧ t2       ::   :: intersection
  | t1 ∨ t2       ::   :: union
  | x             ::   :: tvar
  | sx            ::   :: svar
  | ex            ::   :: evar
  | ( t )         :: S :: paren {{ coq ([[t]]) }}
  | [ t / x ] A   :: M :: subst {{ coq (open_algo_type_wrt_algo_type [[x A]] [[t]]) }}

algo_mode, m :: 'algo_m_' ::=
  | +                :: :: u
  | -                :: :: l

algo_work, w :: 'algo_w_' ::=
  | t1 <: t2         :: :: sub

algo_worklist, wl :: 'algo_wl_' ::= 
  | wnil               ::   :: nil 
  | wl , x             ::   :: cons_tv
  | wl , sx            ::   :: cons_sv
  | wl , t1 ≤ ex ≤ t2  ::   :: cons_ev
  | wl |- w            ::   :: cons_w
  | wl1 ++ wl2         :: M :: app {{ coq (algo_wl_app [[wl1]] [[wl2]]) }}

formula :: formula_ ::=
  | judgement               ::   :: judgement
  | ex notin wl             :: M :: evar_fresh {{ coq ([[ex]] `notin` (evar_dom [[wl]])) }}
  | x notin wl              :: M :: tvar_fresh {{ coq ([[x]] `notin` (tvar_dom [[wl]])) }}
  | m { ex ∪ t } wl -> wl'  :: M :: reorder {{ coq (reorder [[wl]] [[ex]] [[t]] [[m]] algo_wl_nil [[wl']]) }}

substitutions
  single algo_type x :: subst
  single algo_type ex :: ex_subst
  single algo_type sx :: svar_subst

freevars
  algo_type  x   :: ftvar
  algo_type  sx  :: fsvar
  algo_type  ex  :: fevar


embed {{ coq

Fixpoint algo_wl_app (wl1 wl2 : algo_worklist) : algo_worklist :=
  match wl2 with
  | algo_wl_nil => wl1 
  | algo_wl_cons_tv wl2' x2 => algo_wl_cons_tv (algo_wl_app wl1 wl2') x2
  | algo_wl_cons_sv wl2' sx2 => algo_wl_cons_sv (algo_wl_app wl1 wl2') sx2
  | algo_wl_cons_ev wl2' lb2 ex2 ub2 => algo_wl_cons_ev (algo_wl_app wl1 wl2') lb2 ex2 ub2
  | algo_wl_cons_w wl2' w2 => algo_wl_cons_w (algo_wl_app wl1 wl2') w2
  end
.

Fixpoint tvar_dom (wl : algo_worklist) : atoms :=
  match wl with
  | algo_wl_nil => {}
  | algo_wl_cons_tv wl' x => add x (tvar_dom wl')
  | algo_wl_cons_sv wl' _ => tvar_dom wl'
  | algo_wl_cons_ev wl' _ _ _ => tvar_dom wl'
  | algo_wl_cons_w wl' _ => tvar_dom wl'
  end
.

Fixpoint tvar_dom (wl : algo_worklist) : atoms :=
  match wl with
  | algo_wl_nil => {}
  | algo_wl_cons_tv wl' x => add x (tvar_dom wl')
  | algo_wl_cons_sv wl' _ => tvar_dom wl'
  | algo_wl_cons_ev wl' _ _ _ => tvar_dom wl'
  | algo_wl_cons_w wl' _ => tvar_dom wl'
  end
.

Fixpoint evar_dom (wl : algo_worklist) : atoms :=
  match wl with
  | algo_wl_nil => {}
  | algo_wl_cons_ev wl' _ ex _ => add ex (evar_dom wl')
  | algo_wl_cons_tv wl' _ => evar_dom wl'
  | algo_wl_cons_sv wl' _ => evar_dom wl'
  | algo_wl_cons_w wl' _ => evar_dom wl'
  end
.

Fixpoint algo_wl_app_rev (wl1 wl2 : algo_worklist) : algo_worklist :=
  match wl2 with
  | algo_wl_nil => wl1 
  | algo_wl_cons_tv wl2' x2 => algo_wl_app_rev (algo_wl_cons_tv wl1 x2) wl2'
  | algo_wl_cons_sv wl2' sx2 => algo_wl_app_rev (algo_wl_cons_sv wl1 sx2) wl2'
  | algo_wl_cons_ev wl2' lb2 ex2 ub2 => algo_wl_app_rev (algo_wl_cons_ev wl1 lb2 ex2 ub2) wl2'
  | algo_wl_cons_w wl2' w2 => algo_wl_app_rev (algo_wl_cons_w wl1 w2) wl2'
  end
.

Inductive reorder : algo_worklist -> var -> algo_type -> algo_mode -> algo_worklist -> algo_worklist -> Prop :=
  | re_add_ub : forall Γ x lb ub t Γ'
    , x `notin` fevar_algo_worklist Γ' `union` fevar_algo_type t
    -> reorder (algo_wl_cons_ev Γ lb x ub) x t algo_m_u algo_wl_nil 
    (algo_wl_app_rev (algo_wl_cons_ev Γ lb x (algo_t_intersection ub t)) Γ')
  | re_add_lb : forall Γ x lb ub t Γ'
    , x `notin` fevar_algo_worklist Γ' `union` fevar_algo_type t
    -> reorder (algo_wl_cons_ev Γ lb x ub) x t algo_m_l algo_wl_nil 
    (algo_wl_app_rev (algo_wl_cons_ev Γ (algo_t_union lb t) x ub) Γ')
  | re_tvar_stay : forall Γ1 Γ2 x y t m Γ'
    , y `notin` ftvar_algo_worklist Γ' `union` ftvar_algo_type t
    -> reorder Γ1 x t m Γ' Γ2
    -> reorder (algo_wl_cons_tv Γ1 y) x t m Γ' (algo_wl_cons_tv Γ2 y)
  | re_evar_stay : forall Γ1 Γ2 y lb ub x t m Γ'
    , y `notin` fevar_algo_worklist Γ' `union` fevar_algo_type t
    -> reorder Γ1 x t m Γ' Γ2
    -> reorder (algo_wl_cons_ev Γ1 lb y ub) x t m Γ' (algo_wl_cons_ev Γ2 lb y ub)
  | re_evar_move : forall Γ1 Γ2 y lb ub x t m Γ'
    , x `notin` fevar_algo_type lb `union` fevar_algo_type ub
    -> reorder Γ1 x t m (algo_wl_cons_ev Γ' lb y ub) Γ2
    -> reorder (algo_wl_cons_ev Γ1 lb y ub) x t m Γ' (algo_wl_cons_ev Γ2 lb y ub)
  | re_work_stay : forall Γ1 Γ2 t1 t2 x t m Γ' 
    , reorder Γ1 x t m Γ' Γ2
    -> reorder (algo_wl_cons_w Γ1 (algo_w_sub t1 t2)) x t m Γ' (algo_wl_cons_w Γ2 (algo_w_sub t1 t2))
  .

}}


defns
Monotype :: '' ::=

defn
mono A :: :: algo_mono_type :: 'algo_mono_'
by

----------------- :: tvar
mono x

----------------- :: evar
mono ex

----------------- :: int
mono int

mono t1
mono t2
----------------- :: arrow
mono (t1 -> t2)


defns
NotForallType :: '' ::=

defn
~∀ A :: :: algo_notforall_type :: 'algo_nf_'
by

--------------- :: int
~∀ int

--------------- :: var
~∀ x

--------------- :: arrow
~∀ t1 -> t2


defns
InWorklist :: '' ::=

defn
t in wl :: :: algo_in_worklist :: 'algo_inwl_'
by

---------------------------- :: tv_here
x in wl , x

x in wl
---------------------------  :: tv_there_tv
x in wl , y

x in wl 
--------------------------   :: tv_there_ev
x in wl , t1 ≤ ex ≤ t2

x in wl
---------------------------- :: tv_there_w
x in wl |- w

---------------------------- :: ev_here
ex in wl , t1 ≤ ex ≤ t2

ex in wl 
---------------------------- :: ev_there_tv
ex in wl , x

ex in wl 
---------------------------- :: ev_there_ev
ex in wl , t1 ≤ ey ≤ t2

ex in wl
---------------------------- :: ev_there_w
ex in wl |- w


defns
WellFormedType :: '' ::=

defn
wl |=> t  :: :: algo_wf_type :: 'algo_wft_'
by

---------------- :: int
wl |=>  int

ex in wl
----------------- :: evar
wl |=> ex

x in wl 
---------------- :: tvar
wl |=> x

wl |=>  t1 
wl |=>  t2 
---------------- :: arrow
wl |=>  t1 -> t2

wl , x |=> t 
----------------- :: forall 
wl |=> forall x. t


defns
WellFormedMonoType :: '' ::=

defn
wl |==> t  :: :: algo_wf_mtype :: 'algo_wfmt_'
by

---------------- :: int
wl |==> int

x in wl 
---------------- :: tvar
wl |==> x

ex in wl 
---------------- :: evar
wl |==> ex

wl |==> t1
wl |==> t2 
---------------- :: arrow
wl |==> t1 -> t2



defns
InScope :: '' ::=

defn
wl [ t1 ] [ t2 ] :: :: algo_in_scope :: 'algo_ins_'
by

ex1 in wl
------------------------------------ :: ev_here
wl , t1 ≤ ex2 ≤ t2 [ex1] [ex2]


wl [ ex1 ] [ ex2 ]
------------------------------------ :: tv_between
wl , x [ ex1 ] [ ex2 ]


wl [ ex1 ] [ ex2 ]
------------------------------------ :: ev_between
wl , t1 ≤ ex ≤ t2 [ ex1 ] [ ex2 ]


wl [ ex1 ] [ ex2 ]
------------------------------------ :: w_between
wl |- w [ ex1 ] [ ex2 ]


defns 
AlgorithmeticSubtyping :: '' ::=

defn 
|- wl :: :: algo_worklist_reducible :: 'algo_wlred_'
by

x notin wl
|- wl
---------------------------------------------------- :: tvar
|- wl , x

ex notin wl
|- wl |- t1 <: t2
---------------------------------------------------- :: evar_nil_l
|- wl , t1 ≤ ex ≤ t2

|- wl
---------------------------------------------------- :: int_int
|- wl |- int <: int

x in wl
|- wl
---------------------------------------------------- :: tvar_tvar
|- wl |- x <: x

sx in wl 
|- wl
---------------------------------------------------  :: svar_svar
|- wl |- sx <: sx

ex in wl
|- wl
---------------------------------------------------- :: evar_evar
|- wl |- ex <: ex

% sx not in wl
|- wl , sx |- [sx / x] A <: [sx / x] B
---------------------------------------------------- :: forall
|- wl |- forall x. A <: forall x. B

~∀ B
ex notin wl
|- wl , ⊥ ≤ ex ≤ ⊤ |- [ ex / x ] A <: B
---------------------------------------------------- :: forall_l
|- wl |- forall x. A <: B

|- wl |- A2 <: B2 |- B1 <: A1
---------------------------------------------------- :: arrow_arrow
|- wl |- A1 -> A2 <: B1 -> B2

ex in wl
ex1 notin wl 
ex2 notin wl , ⊥ ≤ ex1 ≤ ⊤
+ { ex ∪ (ex1 -> ex2) } wl , ⊥ ≤ ex1 ≤ ⊤ , ⊥ ≤ ex2 ≤ ⊤ -> wl'
|- wl' |- ex1 -> ex2 <: A -> B
---------------------------------------------------- :: evar_arrow
|- wl |- ex <: A -> B

ex in wl
ex1 notin wl 
ex2 notin wl , ⊥ ≤ ex1 ≤ ⊤
- { ex ∪ (ex1 -> ex2) } wl , ⊥ ≤ ex1 ≤ ⊤ , ⊥ ≤ ex2 ≤ ⊤ -> wl'
|- wl' |- A -> B <: ex1 -> ex2 
---------------------------------------------------- :: arrow_evar
|- wl |- A -> B <: ex

wl [ey] [ex]
+ { ex ∪ ey } wl -> wl'
|- wl'
---------------------------------------------------- :: evar_evar_l
|- wl |- ex <: ey

wl [ey] [ex]
- { ex ∪ ey } wl -> wl'
|- wl'
---------------------------------------------------- :: evar_evar_r
|- wl |- ey <: ex

ex in wl
mono t
- { ex ∪ t } wl -> wl'
|- wl'
---------------------------------------------------- :: mono_evar
|- wl |- t <: ex

ex in wl
mono t
+ { ex ∪ t } wl -> wl'
|- wl'
---------------------------------------------------- :: evar_mono
|- wl |- ex <: t

% |- wl
% ----------------------------------------------------- :: top
% |- wl |- A <: ⊤

% |- wl
% ----------------------------------------------------- :: bot
% |- wl |- ⊥ <: A

% |- wl |- A <: B1 |- A <: B2
% ----------------------------------------------------- :: intersection_r
% |- wl |- A <: B1 ∧ B2

% wl |=> A2
% |- wl |- A1 <: B
% ------------------------------------------------------- :: intersection_l1
% |- wl |- A1 ∧ A2 <: B

% wl |=> A1
% |- wl |- A2 <: B
% ------------------------------------------------------- :: intersection_l2
% |- wl |- A1 ∧ A2 <: B

% wl |=> B2
% |- wl |- A <: B1
% ------------------------------------------------------- :: union_r1
% |- wl |- A <: B1 ∨ B2

% |- wl |- A <: B2
% wl |=> B1
% ------------------------------------------------------- :: union_r2
% |- wl |- A <: B1 ∨ B2

% |- wl |- A1 <: B |- A2 <: B
% ------------------------------------------------------- :: union_l
% |- wl |- A1 ∨ A2 <: B



