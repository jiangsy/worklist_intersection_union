metavar typvar, X, Y, Z     ::= {{ repr-locally-nameless }}
metavar expvar, x, y, z     ::= {{ repr-locally-nameless }}

grammar
 
atyp, A, B, C :: atyp_ ::=
  | UNIT           ::   :: unit
  | TOP            ::   :: top
  | BOT            ::   :: bot
  | X              ::   :: tvar
  | A1 -> A2       ::   :: arrow
  | ∀ X . A        ::   :: all  (+ bind X in A +)
  | A1 ⊔ A2        ::   :: union
  | A1 ⊓ A2        ::   :: intersection
  | ( A )          :: S :: paren {{ coq ([[A]]) }}
  | { A2 / X } A1  :: M :: subst {{ coq (open_atyp_wrt_a_typ [[X A1]] [[A2]]) }}

abody :: abody_ ::= 
  | e : A ::  :: anno

aexp, e, f, g :: a_exp_ ::=
  | unit                                ::   :: unit 
  | top                                 ::   :: top
  | x                                   ::   :: var
  | \ x . e                             ::   :: abs  (+ bind x in e +)
  | e1 e2                               ::   :: app
  | \ X . abody                         ::   :: tabs (+ bind X in abody +) 
  | e @ A                               ::   :: tapp
  | e : A                               ::   :: anno
  | ( e )                               :: S :: paren  {{ coq ([[e]]) }}
  | { e2 / x } e1                       :: M :: subst1 {{ coq (open_aexp_wrt_aexp [[x e1]] [[e2]]) }}
  | { A2 / X } e1                       :: M :: subst2 {{ coq (open_aexp_wrt_atyp [[X e1]] [[A2]]) }}

abind, b :: abind_ ::=
  | : ▪        ::   :: tvarempty
  | : ~▪       ::   :: stvarempty
  | : A        ::   :: typ
  | : A1 < A2  ::   :: bound

substitutions
  single A X  :: a_subst_tv_in
  single e x  :: a_subst_v_in

freevars
  A X  :: ftv_in
  e x  :: fv_in

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

aenv, E, F, G :: '' ::= {{ coq list (atom*abind) }}
  | empty    ::   :: empty {{ coq nil }}
  | E , x b  ::   :: consvar {{ coq ([[x]]~[[b]] ++ [[E]])  }}
  | E , X b  ::   :: constvar {{ coq ([[X]]~[[b]] ++ [[E]]) }}
  | ⌊ W ⌋    :: M :: wlenv {{ coq ( a_wl_to_env [[W]] )}}

acont, c :: 'acont_' ::=
  | _ ▹ c                ::   :: infabs
  | _ ⊔▹ A1 ▹ c          ::   :: infabsunion
  | _ • e =>=> c         ::   :: infapp
  | _ ○ A =>=> c         ::   :: inftapp
  | _ ⊔∘ A1 ○ A2 =>=> c  ::   :: inftappunion
  | _ ⊔∘ A2 >> c         ::   :: unioninftapp
  | _ ⊔▹ A2 >> c         ::   :: unioninfabs
  | _ <: A               ::   :: sub
  | ( c )                :: S :: paren  {{ coq ([[c]]) }}

awork, w :: 'awork_' ::=
  | e => c                 ::   :: infer
  | e <= A                 ::   :: check
  | A ▹ c                  ::   :: infabs
  | A1 ⊔▹ A2 ▹ c           ::   :: infabsunion
  | A • e =>=> c           ::   :: infapp
  | A1 ○ A2 =>=> c         ::   :: inftapp
  | A1 <: A2               ::   :: sub
  | A1 ⊔∘ A2 ○ B1 =>=> c   ::   :: inftappunion
  | A1 ⊔∘ A2 >> c          ::   :: unioninftapp
  | A1 ⊔▹ A2 >> c          ::   :: unioninfabs
  | c $ A                  ::   :: apply

a_mode_addbound , m :: 'a_modeab_' ::=
  | +                   ::   :: upper
  | -                   ::   :: lower
  | ±                   ::   :: both

a_worklist, W  :: 'a_wl_' ::=
  | nil      ::   :: nil 
  | W , x b  ::   :: consvar 
  | W , X b  ::   :: constvar
  | W , w    ::   :: consw
  | ( W )    :: S :: paren  {{ coq ([[W]]) }}
  | W1 ++ W2 :: M :: app {{ coq ( a_wl_app [[W2]] [[W1]] )}}

formula :: formula_ ::=
  | judgement                        ::   :: judgement
  | ( x b )  in E                    ::   :: binds1 {{ coq binds ([[x]])  ([[b]]) ([[E]]) }}
  | ( X b )  in E                    ::   :: binds2 {{ coq binds ([[X]])  ([[b]]) ([[E]]) }}
  | x  `notin` E                     ::   :: fresh1 {{ coq ([[x]]  `notin` dom ([[E]])) }}
  | X  `notin` E                     ::   :: fresh2 {{ coq ([[X]]  `notin` dom ([[E]])) }}
  | X `notin` E                      ::   :: fresh4 {{ coq ([[X]] `notin` dom ([[E]])) }}
  | A ¬= TOP                         ::   :: neqtop  {{ coq ~ ([[A]] = a_typ_top)}}
  | W1 ≺⁻ ( X : A ) ~ W2 | W3 ‖ E    ::   :: abrelb {{ coq (a_add_to_bound_and_reorder [[W1]] [[E]] [[X]] [[A]] a_modeab_lower [[W2]] [[W3]])}}
  | W1 ≺⁺ ( X : A ) ~ W2 | W3 ‖ E    ::   :: abreub {{ coq (a_add_to_bound_and_reorder [[W1]] [[E]] [[X]] [[A]] a_modeab_upper [[W2]] [[W3]])}}
  | W1 ≺± ( X : A ) ~ W2 | W3 ‖ E    ::   :: abrebb {{ coq (a_add_to_bound_and_reorder [[W1]] [[E]] [[X]] [[A]] a_modeab_both [[W2]] [[W3]])}}
  | ¬smono A                         ::   :: nsmono {{ coq ( a_smono_typ [[A]] -> False )}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%∥%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
embed {{ coq


Fixpoint a_wl_to_env (Γ : a_worklist) : aenv :=
  match Γ with 
  | a_wl_nil => nil
  | a_wl_consw Γ1' _ => a_wl_to_env Γ1'
  | a_wl_constvar Γ1' X b => X ~ b ++ a_wl_to_env Γ1'
  | a_wl_consvar Γ1' x b => x ~ b ++ a_wl_to_env Γ1'
  end.



(* 
Fixpoint a_wl_app (Γ1 Γ2 : a_worklist) :=
  match Γ1 with 
  | a_wl_nil                 => Γ2 
  | a_wl_constvar Γ1' X b    => a_wl_constvar (a_wl_app Γ1' Γ2) X b
  | a_wl_consvar Γ1' x b     => a_wl_consvar (a_wl_app Γ1' Γ2) x b
  | a_wl_consw Γ1' w         => a_wl_consw (a_wl_app Γ1' Γ2) w
  end.


Definition fx_env_gen (fv : abind -> atoms) (E : aenv) : atoms :=
  fold_right (fun xb acc => match xb with (x , b) => acc `union` fv b end ) {} E.

Definition ftv_in_a_env := fx_env_gen ftv_in_a_binding.
Definition fstv_in_a_env := fx_env_gen fstv_in_a_binding.
Definition fetv_in_a_env := fx_env_gen fetv_in_a_binding.


Definition mono_intersection (A1 A2 : atyp) : atyp :=
  match A2 with
  | a_typ_top => A1 
  | _ => a_typ_intersection A1 A2
  end.

Definition mono_union (A1 A2 : atyp) : atyp :=
  match A2 with
  | a_typ_bot => A1 
  | _ => a_typ_union A1 A2
  end.

Fixpoint a_env_to_wl (E : aenv) : a_worklist :=
  match E with 
  | nil => a_wl_nil
  | (X , abind_tvarempty) :: E' => a_wl_constvar (a_env_to_wl E') X abind_tvarempty
  | (X , abind_stvarempty) :: E' => a_wl_constvar (a_env_to_wl E') X abind_stvarempty
  | (X , abind_bound B1 A1) :: E' => a_wl_constvar (a_env_to_wl E') X (abind_bound B1 A1)
  | (x , abind_typ A1) :: E' => a_wl_consvar (a_env_to_wl E') x (abind_typ A1)
  end.

Inductive a_add_to_bound_and_reorder
  : a_worklist ->  list (atom*abind) -> etypvar -> atyp -> a_mode_addbound -> a_worklist -> a_worklist -> Prop :=
  | a_abr_lbstop : forall Γ1 E X A B1 A1, 
    X `notin` fetv_in_a_typ A -> 
    a_add_to_bound_and_reorder
     (a_wl_consetvar Γ1 X (abind_bound B1 A1)) E X A a_modeab_lower (a_wl_consetvar (a_wl_app (a_env_to_wl E) Γ1) X (abind_bound (mono_union A B1) A1)) a_wl_nil
  | a_abr_ubstop : forall Γ1 E X A B1 A1, 
    X `notin` fetv_in_a_typ A -> 
    a_add_to_bound_and_reorder
     (a_wl_consetvar Γ1 X (abind_bound B1 A1)) E X A a_modeab_upper (a_wl_consetvar (a_wl_app (a_env_to_wl E) Γ1) X (abind_bound B1 (mono_intersection A A1))) a_wl_nil
  | a_abr_bbstop : forall Γ1 E X A B1 A1, 
    X `notin` fetv_in_a_typ A -> 
    a_add_to_bound_and_reorder
     (a_wl_consetvar Γ1 X (abind_bound B1 A1)) E X A a_modeab_upper (a_wl_consetvar (a_wl_app (a_env_to_wl E) Γ1) X (abind_bound (mono_union A B1) (mono_intersection A A1))) a_wl_nil
  | a_abr_etvar_move : forall Γ1 X1 b1 E X A m Γ2 Γ3,
    X `notin` fetv_in_a_binding b1 ->
    a_add_to_bound_and_reorder Γ1 E X A m Γ2 Γ3 ->
    a_add_to_bound_and_reorder (a_wl_consetvar Γ1 X1 b1) ( (X1 , b1) :: E ) X A m Γ2 Γ3
  | a_abr_etvar_stay : forall Γ1 X1 b1 E X A m Γ2 Γ3,
    X1 `notin` fetv_in_a_typ A /\ X1 `notin` fetv_in_a_env E ->
    a_add_to_bound_and_reorder Γ1 E X A m Γ2 Γ3 ->
    a_add_to_bound_and_reorder (a_wl_consetvar Γ1 X1 b1) E X A m Γ2 (a_wl_consetvar Γ3 X1 b1)
  | a_abr_tvar_stay : forall Γ1 X1 b1 E X A m Γ2 Γ3,
    X1 `notin` ftv_in_a_typ A /\ X1 `notin` ftv_in_a_env E ->
    a_add_to_bound_and_reorder Γ1 E X A m Γ2 Γ3 ->
    a_add_to_bound_and_reorder (a_wl_constvar Γ1 X1 b1) E X A m Γ2 (a_wl_constvar Γ3 X1 b1)
  | a_abr_stvar_stay : forall Γ1 SX1 b1 E X A m Γ2 Γ3,
    SX1 `notin` fstv_in_a_typ A /\ SX1 `notin` fstv_in_a_env E ->
    a_add_to_bound_and_reorder Γ1 E X A m Γ2 Γ3 ->
    a_add_to_bound_and_reorder (a_wl_consstvar Γ1 SX1 b1) E X A m Γ2 (a_wl_consstvar Γ3 SX1 b1)
  | a_abr_w_stay : forall Γ1 w1 E X A m Γ2 Γ3,
    a_add_to_bound_and_reorder Γ1 E X A m Γ2 Γ3 ->
    a_add_to_bound_and_reorder (a_wl_consw Γ1 w1) E X A m Γ2 (a_wl_consw Γ3 w1)
  | a_abr_var_stay : forall Γ1 x1 b1 E X A m Γ2 Γ3,
    a_add_to_bound_and_reorder Γ1 E X A m Γ2 Γ3 ->
    a_add_to_bound_and_reorder (a_wl_consvar Γ1 x1 b1) E X A m Γ2 (a_wl_consvar Γ3 x1 b1) 
  .

*)

}}


defns
Ja_tvar_strong_in :: '' ::=

defn
X ∈ₛ A :: :: a_tvar_strongin :: 'a_tvarsin_' by

------------------------ :: var
X ∈ₛ X 

X ∈ₛ A1
------------------------ :: arrow1
X ∈ₛ A1 -> A2 

X ∈ₛ A2
------------------------ :: arrow2
X ∈ₛ A1 -> A2 

X ∈ₛ A
------------------------ :: all
X ∈ₛ ∀ Y . A

X ∈ₛ A1
X ∈ₛ A2
------------------------ :: union
X ∈ₛ A1 ⊔ A2

X ∈ₛ A1
X ∈ₛ A2
------------------------ :: intersection
X ∈ₛ A1 ⊓ A2


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
Jawf_typ :: '' ::=

defn
E |- A :: :: a_wf_typ :: 'a_wftyp_' by

--------- :: unit
E |- UNIT 

--------- :: bot
E |- BOT 

--------- :: top
E |- TOP

(X : ▪) in E
--------------------- :: tvar
E |- X

(X : ~▪) in E
--------------------- :: stvar 
E |- X

(X : B1 < A1) in E
----------------------- :: etvar 
E |- X

E |- A1
E |- A2
-------------- :: arrow
E |- A1 -> A2

X ∈ₛ A1
E , X : ▪ |- A1
-------------------- :: all
E |- ∀ X . A1

E |- A1
E |- A2
------------- :: union
E |- A1 ⊔ A2

E |- A1
E |- A2 
------------- :: intersection
E |- A1 ⊓ A2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns 
Jastrong_mono_typ :: '' ::= 

defn 
smono A :: :: a_smono_typ :: 'a_smtyp_' by 

--------------- :: unit
smono UNIT

--------------- :: tvar
smono X

--------------- :: evar
smono X

smono A1
smono A2
--------------- :: arrow
smono A1 -> A2

defns
Jatyp_neq_all :: '' ::=

defn
A ¬= ∀ :: :: a_typ_neq_all :: 'a_typneqall_' by

------------------------ :: unit
UNIT ¬= ∀

------------------------ :: top
TOP ¬= ∀

------------------------ :: bot
BOT ¬= ∀

------------------------ :: tvar
X ¬= ∀

------------------------ :: stvar
X ¬= ∀

------------------------ :: etvar
X ¬= ∀

------------------------ :: arrow
A1 -> A2 ¬= ∀

------------------------ :: union
A1 ⊔ A2 ¬= ∀

------------------------ :: intersection
A1 ⊓ A2 ¬= ∀


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jatyp_neq_intersection :: '' ::=

defn
A ¬= * :: :: a_typ_neq_intersection :: 'a_typneqinter_' by

------------------------ :: unit
UNIT ¬= *

------------------------ :: top
TOP ¬= * 

------------------------ :: bot
BOT ¬= *

------------------------ :: tvar
X ¬= *

------------------------ :: stvar
X ¬= *

------------------------ :: etvar
X ¬= *

------------------------ :: arrow
A1 -> A2 ¬= *

------------------------ :: all
∀ X . A ¬= *

------------------------ :: union
A1 ⊔ A2 ¬= *

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jatyp_neq_union :: '' ::=

defn
A ¬= + :: :: a_typ_neq_union :: 'a_typnequnion_' by

------------------------ :: unit
UNIT ¬= +

------------------------ :: top
TOP ¬= +

------------------------ :: bot
BOT ¬= +

------------------------ :: tvar
X ¬= +

------------------------ :: stvar
X ¬= +

------------------------ :: etvar
X ¬= +

------------------------ :: arrow
A1 -> A2 ¬= +

------------------------ :: all
∀ X . A ¬= +

------------------------ :: intersection
A1 ⊓ A2 ¬= +

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% defns
% Janeq_abs :: '' ::= 

% defn 
% e ¬= λ :: :: da_exp_neq_abs :: 'a_expneqabs_' by 

% ---------------------- :: unit
% unit ¬= λ

% ---------------------- :: top
% top ¬= λ

% ---------------------- :: var
% x ¬= λ

% ---------------------- :: app
% e1 e2  ¬= λ

% ---------------------- :: tabs
% \ X . e : A ¬= λ

% ---------------------- :: tapp
% e @ A ¬= λ

% ---------------------- :: anno
% e : A ¬= λ


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Jaetvars_in_worklist :: '' ::=

defn 
W [ X1 ] [ X2 ] :: :: a_evs_in_wl :: 'a_evsinwl_' by 

( X1 : B1 < A1 ) in ⌊ W ⌋ 
-------------------------------- :: in
W , X2 : B2 < A2 [ X1 ] [ X2 ] 

W [ X1 ] [ X2 ] 
-------------------------------- :: extravar
W , X b [ X1 ] [ X2 ] 

W [ X1 ] [ X2 ] 
-------------------------------- :: extraw
W , w [ X1 ] [ X2 ] 


% defns
% Jaworklist_reduction :: '' ::=

% defn
% |= W :: :: a_wl_red :: 'a__wlred__' by

% |= W
% ------------------ :: gc_var
% |= W , x : A

% |= W
% ------------------ :: gc_tvar
% |= W , X : ▪

% |= W
% ------------------ :: gc_stvar
% |= W , X : ~▪

% |= W , A <: B
% ------------------ :: gc_stvar
% |= W , X : A < B

% |= W
% ------------------ :: sub_top
% |= W , B1 <: TOP

% |= W
% ------------------- :: sub_bot
% |= W , BOT <: A

% |= W
% ------------------- :: sub_unit
% |= W , UNIT <: UNIT

% |= W
% ----------------- :: sub_tvar
% |= W , X <: X

% |= W , A1 <: B1 , B2 <: A2
% ------------------------------ :: subarrow
% |= W , B1 -> B2 <: A1 -> A2

% A1 ¬= ∀
% A1 ¬= *
% A1 ¬= +
% |= W , X : BOT < TOP , B1 <: A1
% ------------------------------------------------- :: sub_alll
% |= W , ∀ X . B1 <: A1

% |= W , X : ~▪ , B1 <: A1
% ------------------------------------------------- :: sub_all
% |= W , ∀ X . B1 <: ∀ X . A1

% (X : B1 < B2) in ⌊ W ⌋
% ¬smono (A1 -> A2)
% W , X1 : BOT < TOP, X2 : BOT < TOP ≺⁺ ( X : X1 -> X2 ) ~ W2 | W3 ‖ E
% |= ( W2 ++ W3 ) , X1 -> X2 <: A1 -> A2
% --------------------------------------------------------------------------- :: sub_arrow1
% |= W , X <: A1 -> A2

% (X : B1 < B2) in ⌊ W ⌋
% ¬smono (A1 -> A2)
% W , X1 : BOT < TOP, X2 : BOT < TOP ≺⁻ ( X : X1 -> X2 ) ~ W2 | W3 ‖ E
% |= ( W2 ++ W3 ) , A1 -> A2 <: X1 -> X2
% --------------------------------------------------------------------------- :: sub_arrow2
% |= W , A1 -> A2 <: X

% (X : B1 < B2) in ⌊ W ⌋
% (Y : B3 < B4) in ⌊ W ⌋
% W ≺⁻ ( X : Y ) ~ W2 | W3 ‖ E
% W [ X ] [ Y ]
% |= ( W2 ++ W3 )
% -------------------------------------------- :: sub_etvar1
% |= W , Y <: X

% (X : B1 < B2) in ⌊ W ⌋
% (Y : B3 < B4) in ⌊ W ⌋
% W ≺⁺ ( X : Y ) ~ W2 | W3 ‖ E
% W [ X ] [ Y ]
% |= ( W2 ++ W3 )
% -------------------------------------------- :: sub_etvar2
% |= W , X <: Y

% (X : B1 < B2) in ⌊ W ⌋
% smono A1
% W ≺⁻ ( X : A1 ) ~ W2 | W3 ‖ E
% |= ( W2 ++ W3 )
% -------------------------------------------- :: sub_etvarmono1
% |= W , A1 <: X

% (X : A1 < A2) in ⌊ W ⌋
% smono B1
% W ≺⁺ ( X : B1 ) ~ W2 | W3 ‖ E
% |= ( W2 ++ W3 )
% -------------------------------------------- :: sub_etvarmono2
% |= W , X <: B1

% |= W , A1 <: B1 , A1 <: B2
% ----------------------------- :: sub_intersection1
% |= W , A1 <: B1 ⊓ B2

% |= W , B1 <: A1
% -------------------------- :: sub_intersection2
% |= W , B1 ⊓ B2 <: A1

% |= W , B2 <: A1
% ------------------------ :: sub_intersection3
% |= W , B1 ⊓ B2 <: A1

% |= W , B1 <: A1
% ------------------------ :: sub_union1
% |= W , B1 <: A1 ⊔ A2

% |= W , B1 <: A2
% ------------------------ :: sub_union2
% |= W , B1 <: A1 ⊔ A2

% |= W , B1 <: A1 , B2 <: A1
% ---------------------------- :: sub_union3
% |= W , B1 ⊔ B2 <: A1

% |= W , e => _ <: A1
% ------------------------ :: chk_sub
% |= W , e <= A1

% % |= W , X : ▪ , e <= A1 
% % ------------------------- :: chk_all
% % |= W , e <= ∀ X . A1    

% |= W , x : A1 , e <= A2
% ----------------------------- :: chk_absarrow
% |= W , \ x . e <= A1 -> A2    

% (X : A1 < A2) in ⌊ W ⌋
% W , X1 : BOT < TOP, X2 : BOT < TOP ≺± ( X : X1 -> X2 ) ~ W2 | W3 ‖ E
% |= ( W2 ++ W3 ) , x : X1 , e <= X2
% ---------------------------------------------------------------------------- :: chk_absevar
% |= W , \ x . e <= X  

% |= W , x : BOT , e <= TOP 
% ---------------------------  :: chk_abstop
% |= W , \ x . e <= TOP

% |= W , e <= A1 , e <= A2
% ---------------------------  :: chk_inter
% |= W , e <= A1 ⊓ A2 

% |= W , e <= A1 
% ---------------------------  :: chk_union1
% |= W , e <= A1 ⊔ A2 

% |= W , e <= A2
% ---------------------------  :: chk_union2
% |= W , e <= A1 ⊔ A2 

% (x : A) in ⌊ W ⌋ 
% |= W , c $ A
% -------------------------- :: inf_var
% |= W , x => c

% |= W , c $ A , e <= A
% -------------------------- :: inf_anno
% |= W , (e : A) => c

% |= W2 , c $ (∀ X . A) , X : ▪ , e <= A
% ------------------------------------- :: inf_tabs
% |= W , \ X . e : A => c

% |= W , c $ UNIT
% ------------------------------------- :: inf_unit
% |= W , unit => c

% |= W , e1 => ( _ ▹ (_ • e2 =>=> c))
% ------------------------------------- :: inf_app
% |= W , (e1 e2) => c

% |= W , c $ A2 , e <= A1
% ------------------------------------- :: infapparrow
% |= W , A1 -> A2 • e =>=> c

% |= W , c $ A1 -> B1
% --------------------------------------------------------------------------- :: infabs_arr
% |= W , A1 -> B1 ▹ c

% (X : A1 < A2) in ⌊ W ⌋
% W , X1 : BOT < TOP, X2 : BOT < TOP ≺± ( X : X1 -> X2 ) ~ W2 | W3 ‖ E
% |= ( W2 ++ W3 ) , X1 -> X2 ▹ c
% --------------------------------------------------------------------------- :: infabs_evar
% |= W , X ▹ c

% |= W , TOP -> BOT ▹ c
% -------------------------------------------------- :: infappbot
% |= W , BOT ▹ c

% |= W , A1 ▹ c
% -------------------------------------------------- :: infabs_inter1
% |= W , A1 ⊓ A2 ▹ c

% |= W , A2 ▹ c
% -------------------------------------------------- :: infabs_inter2
% |= W , A1 ⊓ A2 ▹ c

% |= W , A1 ▹ ( _ ⊔▹ A2 ▹ c )
% -------------------------------------------------- :: infabs_union
% |= W , A1 ⊔ A2 ▹ c

% |= W , A2 ▹ ( _ ⊔▹ B1 -> C1 >> c )
% -------------------------------------------------- :: infabsunion
% |= W , B1 -> C1 ⊔▹ A2 ▹ c

% |= W , c $ (B1 ⊓ B2) -> (C1 ⊔ C2)
% -------------------------------------------------- :: unioninfabs
% |= W , B2 -> C2 ⊔▹ B1 -> C1 >> c 

% |= W , e => _ ○ B =>=> c
% ------------------------------------- :: inf_tapp
% |= W , e @ B => c

% |= W , c $ {B / X} A
% ------------------------------------- :: inftapp_all
% |= W , ∀ X . A ○ B =>=> c

% |= W , c $ BOT
% ------------------------------------- :: inftapp_bot
% |= W , BOT ○ B =>=> c

% |= W , A1 ○ B =>=> c
% -------------------------------------------------- :: inftapp_inter1
% |= W , A1 ⊓ A2 ○ B =>=> c

% |= W , A2 ○ B =>=> c
% -------------------------------------------------- :: inftapp_inter2
% |= W , A1 ⊓ A2 ○ B =>=> c

% |= W , A1 ○ B =>=> ( _ ⊔∘ A2 ○ B =>=> c )
% -------------------------------------------------- :: inftapp_union
% |= W , A1 ⊔ A2 ○ B =>=> c

% |= W , A2 ○ B =>=> ( _ ⊔∘ C1 >> c)
% -------------------------------------------------- :: inftappunion
% |= W , C1 ⊔∘ A2 ○ B =>=> c

% |= W , c $ C1 ⊔ C2
% -------------------------------------------------- :: unioninftapp
% |= W , C2 ⊔∘ C1 >> c
